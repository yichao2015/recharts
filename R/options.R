#' Set \code{x|yAxis} of Echarts (Primary or Secondary)
#'
#' When an echart object is generated, you can modify it by setting axis using
#' \code{\link{\%>\%}}. \cr \cr
#' You can use work functions \code{setXAxis}, \code{setYAxis}, \code{setX1Axis},
#' \code{setY1Axis}.\cr \cr
#' This function modified a few default options for the axis component in
#' ECharts:
#' \enumerate{
#'  \item \code{scale = TRUE} (was \code{FALSE} by default in ECharts);
#'  \item \code{axisLine$onZero = FALSE} (was \code{TRUE} in ECharts).
#' }
#' @param chart \code{echarts} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param series Which series to be put on this axis. Could be:
#' \itemize{
#'  \item series names, in vectors. E.g, \code{c('setosa', 'virginica')};
#'  \item index of series, in vectors. E.g., \code{1:2} or \code{c(1,3)}.
#' }
#' @param which Which axis to be modified. Could be one of the following:
#' \describe{
#'  \item{x}{primary x axis}
#'  \item{y}{primary y axis}
#'  \item{x1}{secondary x axis}
#'  \item{y1}{secondary y axis}
#' }
#' @param type Type of the axis. Could be \code{c('time', 'value', 'category', 'log')}.
#' Default 'value'.
#' @param show Logical, whether to show this axis. Default TRUE.
#' @param position Position of this axis. Could be \code{c('bottom', 'top', 'left',
#' 'right')} (default for primary x axis, secondary x axis, primary y axis and secondary
#' y axis, respectively.)
#' @param name Name of this axis. Default not set ("").
#' @param nameLocation Axis name location. Could be \code{c('end', 'start')}. Default
#' 'end'.
#' @param nameTextStyle Axis name text style. Could be a list of \code{textStyle}
#' features. Default following textStyle global settings.
#' @param boundaryGap A two-element numeric vector, defining the policy of the space
#' at the two ends of the axis (percents). Deafult \code{c(0, 0)}.
#' @param min The mininum value of the axis. Default NULL (automatic). If a numeric
#' value is set, \code{boundaryGap} is disabled.
#' @param max The maxinum value of the axis. Default NULL (automatic). If a numeric
#' value is set, \code{boundaryGap} is disabled.
#' @param scale Logical, for axis of 'value', 'time', 'log' type, to define whether
#' zoom the scale to the range between _min and _max. Default TRUE.
#' @param splitNumber Numeric, how many sections to devide the axis. Default NULL,
#' automatically deviding based on algorithms of \code{min} and \code{max}.
#' @param axisLine A list. Default: \cr
#' \code{list(show=TRUE, onZero=FALSE, lineStyle=list( \cr
#' type='solid', color='#48b', width=2, shadowColor='rgba(0,0,0,0)', shadowBlur=5,
#' shadowOffsetX=3, shadowOffsetY=3))} \cr \cr
#' \code{lineStyle} accepts features \code{color, width, type, shadowColor, shadowBlur,
#' shadowOffsetX, shadowOffsetY}
#' @param axisTick A list. Default: \cr
#' \code{show=FALSE, inside=FALSE, length=5, lineStyle=list(color="#333", width=1)} \cr \cr
#' \code{lineStyle} accepts feature \code{color, width, type, shadowColor, shadowBlur,
#' shadowOffsetX, shadowOffsetY}
#' @param axisLabel A list controlling the axis labels. Default \code{show=TRUE,
#' rotate=0, margin=8, clicable=FALSE, formatter=NULL, textStyle=list(color="#333")} \cr \cr
#' \code{textStyle} accepts features \code{color, align, baseline, fontFamily, fontSize,
#' fontStyle, fontWeight}. \cr \cr
#' \strong{\code{formatter}}:
#' \describe{
#'  \item{sprintf/format string}{String to override \code{axisLable$formatter}.
#'  It accepts \code{sprintf} (category and value) and \code{strptime} (time) formats.}
#'  \item{js mode}{a JS function/expression, which is default}
#' } \cr
#' \code{axisLabel=list(formatter="\%s cm")} is equal to \cr
#' \code{axisLabel=list(formatter=JS('function(value) return{value + "cm";}'))} or \cr
#' \code{axisLabel=list(formatter='{value} cm')}
#' @param splitLine A list controlling the split lines. Default \code{show=TRUE,
#' lineStyle=list(color=list("#ccc"), width=1, type="solid")} \cr \cr
#' \code{lineStyle} accepts features \code{color, width, type, shadowColor, shadowBlur,
#' shadowOffsetX, shadowOffsetY}.
#' @param splitArea A list controlling the split areas. Default \code{show=FALSE,
#' onGap=NULL, areaStyle= list(color= list("rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)")
#' , type="default"} \cr \cr
#' \code{areaStyle} accepts features \code{color, type}.
#' @param data A character vector/list for axis of type 'category', to define the text
#' labels shown in this axis. Default NULL. You can even pass in a complicated list with
#' \code{textSytle} list: \cr
#' \code{list('Jan', 'Feb', 'Mar', \cr list(value='Apr', textStyle=list(color='red', ...)),
#' \cr 'May', ...)}
#'
#' @export
#' @seealso \code{\link{setXAxis}}, \code{\link{setYAxis}}, \code{\link{setX1Axis}},
#' \code{\link{setY1Axis}}
#' @references
#' \url{http://echarts.baidu.com/echarts2/doc/option.html#tooltip-line1~xAxis-i}
#'
#' \url{http://echarts.baidu.com/echarts2/doc/option.html#tooltip-line1~yAxis-i}
#' @examples
#' \dontrun{
#' g <- echartR(iris, Sepal.Width, Petal.Width, series=Species)
#'
#' # Change the style
#' g %>% setTheme('gray') %>% setXAxis(splitLine=list(show=FALSE)) %>%
#'       setYAxis(axisLine=list(lineStyle=list(width=0)))
#'
#' # Dual-yAxis, series 1,2 on primary y-axis, series 3 on secondary y-axis
#' g %>% setYAxis(1:2, name="setosa/versicolor") %>%
#'       setY1Axis("virginica", name="virginica")
#' }
setAxis = function(
    chart, series = NULL, which = c('x', 'y', 'x1', 'y1'),
    type = c('value', 'category', 'time', 'log'), show = TRUE,
    position = c('bottom', 'top', 'left', 'right'),
    name = '', nameLocation = c('end', 'start'), nameTextStyle = emptyList(),
    boundaryGap = c(0, 0), min = NULL, max = NULL, scale = TRUE, splitNumber = NULL,
    axisLine = list(show = TRUE, onZero = FALSE), axisTick = list(show = FALSE),
    axisLabel = list(show = TRUE), splitLine = list(show = TRUE),
    splitArea = list(show = FALSE), data = list()
) {
    stopifnot(inherits(chart, 'echarts'))
    which = match.arg(which)
    axIdx = ifna(as.integer(substr(which, 2, 3)), 0)  # 0：main ax， 1： sub ax
    which = substr(which, 0, 1)  # x or y axis
    hasZ = "timeline" %in% names(chart$x)
    allSeries = getSeriesPart(chart, 'name')  # all levels of series
    if (!is.null(allSeries) && !is.null(series)){
        if (is.numeric(series)){
            series = intersect(series, seq_len(length(allSeries)))
            series = if (length(series) > 0) allSeries[series] else NULL
        }else{
            series = intersect(series, allSeries)
            if (length(series) == 0) series = NULL
        }
    }else{
        series = NULL
    }
    # get intersect of the series

    # if data parially on main axis, the rest on sub axis
    series1 = NULL
    if (length(series) > 0 && length(series) < length(allSeries) && axIdx == 1)
        series1 = allSeries[! allSeries %in% series]

    # original data along the axis
    if (hasZ){
        odata = lapply(chart$x$options, getMeta)
        if (!is.null(series)) {
            sdata = lapply(odata, function(lst) lst['series'])
            sdata = do.call('rbind', sdata)[,1]
        }
        odata = lapply(odata, function(lst) lst[[which]])
        odata = do.call('rbind', odata)[,1]
    }else{
        odata = getMeta(chart)[[which]][,1]
        if (!is.null(series)) sdata = getMeta(chart)[['series']][,1]
    }
    if (!is.null(series)) {
        odata1 = odata[! sdata %in% series]
        odata = odata[sdata %in% series]
    }
    # only get odata of specific series

    if (missing(type)) type = axisType(odata, which)
    if (missing(position)) {
        if (which == 'x') {
            position = if (axIdx == 0) 'bottom' else 'top'
        }else{
            position = if (axIdx == 0) 'left' else 'right'
        }
    }
    if (position %in% c('bottom', 'top'))
        position1 = c('bottom', 'top')[c('bottom', 'top') != position]
    if (position %in% c('left', 'right'))
        position1 = c('left', 'right')[c('left', 'right') != position]
    data1 = list()
    if (missing(data) && type == 'category') {
        data = unique(odata)
        #data = I(levels(as.factor(odata)))
        if (!is.null(series1))
            #data1 = I(levels(as.factor(odata1)))
            data1 = unique(odata1)
    }

    if (!is.null(axisLabel$formatter)) {
        if (!is.list(axisLabel$formatter)){
            axisLabel = mergeList(axisLabel, list(
                formatter=convFormat2JS(axisLabel$formatter, type)))
        }
    }

    if (hasZ) x = chart$x$options[[1]] else x = chart$x
    i = paste0(which, 'Axis')
    o = list(
        type = match.arg(type), show = show, position = match.arg(position),
        name = name, nameLocation = match.arg(nameLocation), nameTextStyle = nameTextStyle,
        boundaryGap = boundaryGap, min = min, max = max, scale = scale,
        splitNumber = splitNumber, axisLine = axisLine, axisTick = axisTick,
        axisLabel = axisLabel, splitLine = splitLine, splitArea = splitArea, data = data
    )
    if (!is.null(series1))
        o1 = list(
            type = match.arg(type), show = show, position = position1, #name = name,
            nameLocation = match.arg(nameLocation),
            nameTextStyle = nameTextStyle, boundaryGap = boundaryGap, min = min,
            max = max, scale = scale, splitNumber = splitNumber, axisLine = axisLine,
            axisTick = axisTick, axisLabel = axisLabel, splitLine = splitLine,
            splitArea = splitArea, data = data1
        )
    if (length(x[[i]]) > 0) {
        # only merge the arguments that are not missing, e.g. eAxis(min = 0) will
        # only override 'min' but will not override the 'name' attribute
        a = intersect(names(as.list(match.call()[-1])), names(o))
        if (!is.null(series1))
            a1 = intersect(names(as.list(match.call()[-1])), names(o1))
        if (length(x[[i]]) < 2 && axIdx == 1)
            x[[i]][[axIdx+1]] <- mergeList(list(), o)
        x[[i]][[axIdx+1]] = mergeList(x[[i]][[axIdx+1]], o[a])

        if (!is.null(series1))
            x[[i]][[2-axIdx]] = mergeList(x[[i]][[2-axIdx]], o1[a1])
    } else {
        x[[i]][[axIdx+1]] = list()
        x[[i]][[axIdx+1]] = mergeList(x[[i]][[axIdx+1]], o)
        if (!is.null(series1)){
            if (length(x[[i]][[2-axIdx]]) == 0) x[[i]][[2-axIdx]] = list()
            x[[i]][[2-axIdx]] = mergeList(x[[i]][[2-axIdx]], o1)
        }
    }
    if (hasZ) chart$x$options[[1]] = x else chart$x = x

    # revise axisIndex
    ax = paste0(which, "AxisIndex")
    if (!is.null(series1)){
        if (axIdx == 0) seriesAx1 = series1 else seriesAx1 = series
        seriesAx1 = which(allSeries %in% seriesAx1)
        if (hasZ){
            for (i in 1:length(chart$x$options)){
                chart$x$options[[i]]$series[[seriesAx1]][[ax]] = 1
            }
        }else{
            chart$x$series[[seriesAx1]][[ax]] = 1
        }
    }

    return(chart)
}

#' @export
#' @rdname setAxis
setYAxis = function(chart, ...) {  # set primary y axis
    setAxis(chart, which = 'y', ...)
}

#' @export
#' @rdname setAxis
setY1Axis = function(chart, ...) {  # set secondary y axis
    setAxis(chart, which = 'y1', ...)
}

#' @export
#' @rdname setAxis
setXAxis = function(chart, ...) {  # set primary x axis
    setAxis(chart, which = 'x', ...)
}

#' @export
#' @rdname setAxis
setX1Axis = function(chart, ...) {  # set secondary x axis
    setAxis(chart, which = 'x1', ...)
}

axisType = function(data, which = c('x', 'y')) {
    if (is.numeric(data) || is.null(data)) return('value')
    if (is.factor(data) || is.character(data)) return('category')
    if (inherits(data, c('Date', 'POSIXct', 'POSIXlt'))) return('time')
    message('The structure of the ', which, ' variable:')
    str(data)
    stop('Unable to derive the axis type automatically from the ', which, ' variable')
}

flipAxis <- function(chart, flip=TRUE, ...){
    # flip x|y-axis
    if (!flip) return(chart)
    stopifnot(inherits(chart, 'echarts'))
    hasZ <- 'timeline' %in% names(chart$x)
    if (hasZ){
        if ('xAxis' %in% names(chart$x$options[[1]]) &&
            'yAxis' %in% names(chart$x$options[[1]])) {
            axes <- exchange(chart$x$options[[1]]$xAxis,
                             chart$x$options[[1]]$yAxis)
            chart$x$options[[1]]$xAxis <- axes[[1]]
            chart$x$options[[1]]$yAxis <- axes[[2]]
        }
    }else{
        if ('xAxis' %in% names(chart$x) &&
            'yAxis' %in% names(chart$x)){
            axes <- exchange(chart$x$xAxis, chart$x$yAxis)
            chart$x$xAxis <- axes[[1]]
            chart$x$yAxis <- axes[[2]]
        }
    }
    return(chart %>% reElementId())
}


#' Set \code{grid} of Echarts Widgets And Pane
#'
#' When an echart object is generated, you can modify it by setting grid using
#' \code{\link{\%>\%}}. \cr
#' \strong{It is recommended to put \code{setGrid} at the end of the piped command.} \cr
#' When used for 'pane', it is only applicable for \code{scatter, point, bubble,
#' line, area, bar, histogram}. When used for 'timeline', it only take in params
#' \code{x, y, x2, y2}. When used for 'legend', 'title', 'dataZoom', 'dataRange',
#'  'toolbox', 'roamController', it only takes in params \code{x, y}.
#'
#' @param chart \code{echarts} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param widget Widget name to set. Could be \code{c('pane', 'timeline', 'legend',
#' 'title', 'dataZoom', 'dataRange', 'toolbox', 'roamController')}.
#' \describe{
#' \item{pane}{the area pane, takes in all the parameters}
#' \item{timeline}{timeline widget, only use \code{x, y, x2, y2}}
#' \item{legend, title, dataZoom, dataRange, toolbox, roamController}{other widgets,
#' only use \code{x, y}}
#' }
#' @param x x coordinate of the left upper point of the plot area. Default 80px.
#' @param y y coordinate of the left upper point of the plot area. Default 60px.
#' @param x2 x coordinate of the right lower point of the plot area. Default 80px.
#' @param y2 y coordinate of the right lower point of the plot area. Default 60px.
#' @param width Width of the plot area. Default NULL (automatically configured)
#' @param height Height of the plot area. Default NULL (automatically configured)
#' @param bgColor background color of plot area. Default transparent ('rgba(0,0,0,0)').
#' @param borderColor border color of the plot area. Default '#ccc'.
#' @param borderWidth border width of the plot area. Default 0px (not shown).
#' @param ... Elipsis.
#'
#' @return A modified echarts object
#' @export
#' @seealso \code{\link{relocWidget}}
#' @references \url{http://echarts.baidu.com/echarts2/doc/option.html#title~grid}
#' @examples
#' \dontrun{
#' g <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, series=Species)
#' g %>% setGrid(x=40, y=40, x2=70, y2=30, bgColor='gray90')
#' }
setGrid <- function(chart, x=80, y=60, x2=80, y2=60, width=NULL, height=NULL,
                    bgColor=NULL, borderColor=NULL, borderWidth=1,
                    widget=c('pane', 'timeline', 'legend', 'title', 'dataZoom',
                             'dataRange', 'toolbox', 'roamController'), ...){
    stopifnot(inherits(chart, 'echarts'))
    hasZ <- 'timeline' %in% names(chart$x)
    types <- getSeriesPart(chart, 'type')
    widget <- match.arg(widget)
    if (widget == 'pane') widget <- 'grid'
    lstGrid <- list()
    if (! missing(x)) if (ifnull(x, 80) != 80) lstGrid[['x']] <- x
    if (! missing(y)) if (ifnull(y, 60) != 60) lstGrid[['y']] <- y
    if (widget %in% c('grid', 'timeline')){
        if (! missing(x2)) if (ifnull(x2, 80) != 80) lstGrid[['x2']] <- x2
        if (! missing(y2)) if (ifnull(y2, 60) != 60) lstGrid[['y2']] <- y2
    }
    if (widget == 'grid'){
        if (! missing(width)) if (! is.null(width))
            lstGrid[['width']] <- width
        if (! missing(height)) if (! is.null(height))
            lstGrid[['height']] <- height
        if (! missing(borderWidth)) if (ifnull(borderWidth, 0) > 0)
            lstGrid[['borderWidth']] <- borderWidth
        if (! missing(borderColor)) if (borderColor != '#ccc')
            lstGrid[['borderColor']] <- borderColor
        if (! missing(bgColor)) if (bgColor != 'rgba(0,0,0,0)')
            lstGrid[['backgroundColor']] <- getColors(bgColor)[1]
    }
    ## wrap up
    if (hasZ){
        if (widget == 'timeline'){
            chart$x$timeline <- mergeList(chart$x$timeline, lstGrid)
        }else if((widget == 'grid' &&
                  all(types %in% c('scatter', 'point', 'bubble', 'line', 'bar'))) ||
                  widget %in% names(chart$x$options[[1]])){
            chart$x$options[[1]][[widget]] <-
                mergeList(chart$x$options[[1]][[widget]], lstGrid)
        }
    }else{
        if ((widget == 'grid' &&
            all(types %in% c('scatter', 'point', 'bubble', 'line', 'bar'))) ||
            widget %in% names(chart$x))
                chart$x[[widget]] <- mergeList(chart$x[[widget]], lstGrid)
    }

    return(chart %>% reElementId())
}

#' @export
#' @rdname setGrid
relocTitle <- function(chart, x=NULL, y=NULL, ...){
    setGrid(chart, x=x, y=y, widget='title', ...)
}

#' @export
#' @rdname setGrid
relocLegend <- function(chart, x=NULL, y=NULL, ...){
    setGrid(chart, x=x, y=y, widget='legend', ...)
}

#' @export
#' @rdname setGrid
relocDataZoom <- function(chart, x=NULL, y=NULL, ...){
    setGrid(chart, x=x, y=y, widget='dataZoom', ...)
}

#' @export
#' @rdname setGrid
relocDataRange <- function(chart, x=NULL, y=NULL, ...){
    setGrid(chart, x=x, y=y, widget='dataRange', ...)
}

#' @export
#' @rdname setGrid
relocTimeline <- function(chart, x=NULL, y=NULL, x2=NULL, y2=NULL, ...){
    setGrid(chart, x=x, y=y, x2=x2, y2=y2, widget='timeline', ...)
}

#' @export
#' @rdname setGrid
relocToolbox <- function(chart, x=NULL, y=NULL, ...){
    setGrid(chart, x=x, y=y, widget='toolbox', ...)
}

#' @export
#' @rdname setGrid
relocRoam <- function(chart, x=NULL, y=NULL, ...){
    setGrid(chart, x=x, y=y, widget='roamController', ...)
}

#' Re-locate Echarts Widgets (Position of Upper-left/Lower-right Point)
#'
#' @param chart Echarts object
#' @param widgets Vector or list, could be \code{'title', 'timeline', 'legend', 'toolbox',
#' 'dataRange', 'dataZoom', 'roamController'}
#' @param x Vector, x-coordinates of the widgets' upper-left point
#' @param y Vector, y-coordinates of the widgets' upper-left point
#' @param x2 Vector, x-coordinates of the widgets' lower-right point
#' @param y2 Vector, y-coordinates of the widgets' lower-right point
#' @note If \code{x, y, x2, y2} are shorter in length than the list \code{widgets},
#' the last element of \code{x, y, x2, y2} will be applied to cover the rest.
#' If \code{x, y, x2, y2} are longer in length than the list \code{widgets},
#' the redundent elements will be dropped.
#' @return A modified Echarts object
#' @export
#' @seealso \code{\link{setGrid}}
#' @examples
#' \dontrun{
#' g <- echartR(iris, Sepal.Width, Petal.Width) %>% setDataZoom()
#' g %>% relocWidgets('dataZoom', x=150)
#' }
relocWidget <- function(chart, widgets, x=NULL, y=NULL, x2=NULL, y2=NULL){
    stopifnot(inherits(chart, 'echarts'))
    stopifnot(all(widgets %in% c('title', 'timeline', 'legend', 'toolbox',
                                 'dataRange', 'dataZoom', 'roamController')))
    if (!missing(x)) if (!is.null(x)) x <- if (length(x) < length(widgets))
        c(x, rep(x[length(x)], length(widgets) - length(x))) else x[length(widgets)]
    if (!missing(y)) if (!is.null(y)) y <- if (length(y) < length(widgets))
        c(y, rep(y[length(y)], length(widgets) - length(y))) else x[length(widgets)]
    if (!missing(x2)) if (!is.null(x2)) x <- if (length(x2) < length(widgets))
        c(x2, rep(x2[length(x2)], length(widgets) - length(x2))) else x[length(widgets)]
    if (!missing(y2)) if (!is.null(y2)) x <- if (length(y2) < length(widgets))
        c(y2, rep(y2[length(y2)], length(widgets) - length(y2))) else x[length(widgets)]
    for (i in 1:length(widgets)){
        chart <- chart %>% setGrid(x[i], y[i], x2[i], y2[i], widget=widgets[i])
    }
    return(chart %>% reElementId())
}


.getGridParam <- function(chart, control, pos, size, horizontal=TRUE){
    stopifnot(length(pos) == 4)  ## x, y, x2, y2
    stopifnot(length(size) == 2) ## height, width
    hasZ <- 'timeline' %in% names(chart$x)
    if (hasZ){
        if (control == 'timeline')  obj <- chart$x$timeline
        else obj <- chart$x$options[[1]][[control]]
    }else{
        obj <- chart$x[[control]]
    }
    lst <- lapply(c('x', 'y', 'x2', 'y2', 'orient', 'height', 'width'),
                  function(param){obj[[param]]})
    lstDefault <- c(as.list(pos), ifelse(horizontal, 'horizontal', 'vertical'),
                    as.list(size))
    names(lst) <- names(lstDefault) <-  c('x', 'y', 'x2', 'y2', 'orient',
                                          'height', 'width')

    if (!is.null(obj))
        lst <- unlist(mergeList(lstDefault, lst, keep.null=TRUE,
                                skip.merge.null=TRUE))
    # x, y , orient
    else return(rep(NA, 8))

    # x, y, x2, y2, width, height
    x <- ifelse(lst['x'] %in% c('left', 'center', 'right'), lst['x'],
                ifelse(grepl("document\\.getElementById", lst['x']), 'right',
                       suppressWarnings(as.numeric(lst['x']))))
    if (is.numeric(x)) x <- if (ifna(x, 0) < 80) 'left' else
        if (ifna(x, 0) < 400) 'center' else 'right'
    y <- ifelse(lst['y'] %in% c('top', 'center', 'bottom'), lst['y'],
                ifelse(grepl("document\\.getElementById", lst['y']), 'bottom',
                       suppressWarnings(as.numeric(lst['y']))))
    if (is.numeric(y)) y <- if (ifna(y, 0) < 60) 'top' else
        if (ifna(y, 0) < 400) 'center' else 'bottom'

    x2 <- suppressWarnings(as.numeric(lst['x2']))
    y2 <- suppressWarnings(as.numeric(lst['y2']))
    height <- suppressWarnings(as.numeric(lst['height']))
    width <- suppressWarnings(as.numeric(lst['width']))
    pos <- ifelse(length(clockPos(x, y, lst['orient'])) == 0, 12,
                  clockPos(x, y, lst['orient']))

    x <- suppressWarnings(as.numeric(lst['x']))
    y <- suppressWarnings(as.numeric(lst['y']))
    if (is.na(x)) x <- ifnull(switch(lst['x'], left=0, center=0, right=NA), 0)
    if (is.na(x2)) x2 <- ifnull(switch(lst['x'], left=NA, center=0, right=0), 0)
    if (is.na(y)) y <- ifnull(switch(lst['y'], top=0, center=0, bottom=NA), 0)
    if (is.na(y2)) y2 <- ifnull(switch(lst['y'], top=NA, center=0, bottom=0), 0)

    return(c(pos, x, y, x2, y2, height, width, unname(lst['orient']=='horizontal')))
}



#' @export
#' @importFrom data.table data.table
tuneGrid <- function(chart, ...){
    # tune the grid of pane and widgets
    stopifnot(inherits(chart, 'echarts'))
    types <- getSeriesPart(chart, 'type')
    hasZ <- 'timeline' %in% names(chart$x)
    # if not Cartesian Coord chart, skip out

    controls <- c('title', 'timeline', 'legend', 'toolbox', 'dataRange',
                  'dataZoom', 'roamController')
    gridParam <- c('pos', 'x', 'y', 'x2', 'y2', 'height', 'width', 'orient')
    dfGrid <- data.frame(matrix(ncol=length(gridParam), nrow=length(controls)))
    colnames(dfGrid) <- gridParam
    rownames(dfGrid) <- controls

    #---------- get x, y, x1, y1 of each control --------------
    dfGrid['title',] <- .getGridParam(
        chart, 'title', c('center', 'bottom', NA, NA), c(50, 50))
    dfGrid['legend',] <- .getGridParam(
        chart, 'legend', c('left', 'top', NA, NA), c(50, 50))
    dfGrid['dataRange',] <- .getGridParam(
        chart, 'dataRange', c('left', 'bottom', NA, NA), c(50, 120), FALSE)
    dfGrid['dataZoom',] <- .getGridParam(
        chart, 'dataZoom', c('center', 'bottom', NA, NA), c(30, 30))
    dfGrid['toolbox',] <- .getGridParam(
        chart, 'toolbox', c('right', 'top', NA, NA), c(50, 50))
    dfGrid['timeline',] <- .getGridParam(
        chart, 'timeline', c('center', 'bottom', 80, 0), c(50, 50))
    dfGrid['roamController',] <- .getGridParam(
        chart, 'roamController', c('right', 'top', NA, NA), c(80, 150), FALSE)
    # remove all NA rows
    dfGrid <- dfGrid[!(apply(dfGrid, 1, function(row) all(is.na(row)))),]

    #dfGrid <<- dfGrid
    # browser()

    sumGrid <- dcast(data.table(dfGrid), orient + pos ~ ., fun=sum,
                     value.var=c("x", "y", "x2", "y2", "height", "width"))
    uniqueGrid <- dfGrid[!duplicated(dfGrid$pos),]
    sumGrid[,c('x_sum_.', 'y_sum_.', 'x2_sum_.', 'y2_sum_.')] <-
        uniqueGrid[, c('x', 'y', 'x2', 'y2')]
    sumGrid$x <- ifblank(
        rowSums(sumGrid[,list(x_sum_., width_sum_.)], na.rm=TRUE), NA)
    sumGrid$y <- ifblank(
        rowSums(sumGrid[,list(y_sum_., height_sum_.)], na.rm=TRUE), NA)
    sumGrid$x2 <- ifblank(
        rowSums(sumGrid[, list(x2_sum_., width_sum_.)], na.rm=TRUE), NA)
    sumGrid$y2 <- ifblank(
        rowSums(sumGrid[, list(y2_sum_., height_sum_.)], na.rm=TRUE), NA)

    #uniqueGrid <<- uniqueGrid
    #sumGrid <<- sumGrid

    lstGrid <- list()
    if (length(sumGrid[pos %in% c(8, 9, 10), x]) > 0)
        if (max(sumGrid[pos %in% c(8, 9, 10), x]) > 70)
            lstGrid$x <- max(ifblank(sumGrid[pos == 9, x], 70)) + 20
    if (length(sumGrid[pos %in% c(11, 12, 1), y]) > 0)
        if (max(sumGrid[pos %in% c(11, 12, 1), y]) > 50)
            lstGrid$y <- max(ifblank(sumGrid[pos == 12, y], 50)) + 30
    if (length(sumGrid[pos %in% c(2, 3, 4), x2]) > 0)
        if (max(sumGrid[pos %in% c(2, 3, 4), x2]) > 70)
            lstGrid$x2 <- max(ifblank(sumGrid[pos == 3, x2], 70)) + 20
    if (length(sumGrid[pos %in% c(5, 6, 7), y2]) > 0)
        if (max(sumGrid[pos %in% c(5, 6, 7), y2]) > 50)
            lstGrid$y2 <- max(ifblank(sumGrid[pos == 6, y2], 50)) + 30

    ## tune grid if there are duplicated pos
    if (any(duplicated(dfGrid$pos))){
        dupPos <- table(dfGrid$pos)
        dupPos <- as.numeric(names(dupPos[dupPos > 1]))
        for (i in dupPos){
            dfDupGrid <- dfGrid[dfGrid$pos == i,]
            len <- nrow(dfDupGrid)
            widgets <- row.names(dfDupGrid)[2:len]
            widgetsNotTL <- widgets[!widgets %in% 'timeline']
            dfDupGrid$cumHeight <- cumsum(dfDupGrid$height)
            dfDupGrid$cumWidth <- cumsum(dfDupGrid$width)
            sizeParam = ifelse(i %in% c(1, 5, 6, 7, 11, 12), 'height', 'width')

            if (i %in% c(11, 12, 1)){
                cumSize <- ifna(dfDupGrid[1, 'y'],0) +
                    dfDupGrid[1: (len - 1), c("cumHeight")]
                w = 'y'
                w2 = 'y2'
            }else if (i %in% c(2, 3, 4)){
                cumSize <- ifna(dfDupGrid[1, 'x2'],0) +
                    dfDupGrid[1: (len - 1), c("cumWidth")]
                w = 'x2'
                w2 = 'x'
            }else if (i %in% c(5, 6, 7)){
                cumSize <- ifna(dfDupGrid[1, 'y2'],0) +
                    dfDupGrid[1: (len - 1), c("cumHeight")]
                w = 'y2'
                w2 = 'y'
            }else if (i %in% c(8, 9, 10)){
                cumSize <- ifna(dfDupGrid[1, 'x'],0) +
                    dfDupGrid[1: (len - 1), c("cumWidth")]
                w = 'x'
                w2 = 'x2'
            }

            names(cumSize) <- widgets

            if (hasZ){
                for (j in widgets){
                    if (j == 'timeline') chart$x[[j]][[w]] = unname(cumSize[j])
                    else {
                        chart$x$options[[1]][[j]][[w]] = unname(cumSize[j])
                        if (w %in% c('x2', 'y2'))
                        #      chart$x$options[[1]][[j]][[w2]] =
                        #          dev.size('px')[ifelse(w == 'x2', 1, 2)] - 10 -
                        #          dfGrid[j, sizeParam] - chart$x$options[[1]][[j]][[w]]
                            chart$x$options[[1]][[j]][[w2]] = JS(
                                paste0(getJSElementSize(
                                    chart, ifelse(w == 'x2', 'Width', "Height")),
                                    " - ", dfGrid[j, sizeParam] +
                                        chart$x$options[[1]][[j]][[w]]))
                    }
                }
            }else{
                for (j in widgets) {
                    chart$x[[j]][[w]] = unname(cumSize[j])
                    if (w %in% c('x2', 'y2'))
                        # chart$x[[j]][[w2]] =
                        #     dev.size('px')[ifelse(w == 'x2', 1, 2)] - 10 -
                        #     dfGrid[j, sizeParam] - chart$x[[j]][[w]]
                        chart$x[[j]][[w2]] = JS(
                            paste0(getJSElementSize(
                                chart, ifelse(w == 'x2', 'Width', "Height")),
                                " - ", dfGrid[j, sizeParam] +
                                    chart$x[[j]][[w]]))
                }
            }
        }
    }

    ## additional tuning
    if ('dataZoom' %in% row.names(dfGrid))
        if (dfGrid['dataZoom', 'orient'] == 1){
            if (hasZ) chart$x$options[[1]]$dataZoom$x <- ifnull(lstGrid$x, 80)
            else chart$x$dataZoom$x <- ifnull(lstGrid$x, 80)
        }else{
            if (hasZ) chart$x$options[[1]]$dataZoom$y <- ifnull(lstGrid$y, 60)
            else chart$x$dataZoom$y <- ifnull(lstGrid$y, 60)
        }
    if ('timeline' %in% row.names(dfGrid)){
        chart$x$timeline$x <- ifnull(lstGrid$x, 80)
        chart$x$timeline$x2 <- ifnull(lstGrid$x2, 80)
    }

    ## wrap up
    # collect all grid features
    if (all(types %in% c('scatter', 'line', 'bar', 'k')))
        if (length(lstGrid) > 0){
            if (hasZ)
                chart$x$options[[1]][['grid']] <- lstGrid
            else
                chart$x[['grid']] <- lstGrid
        }
    return(chart %>% reElementId())
}

makeTitle <- function(title=NULL, subtitle=NULL, link=NULL, sublink=NULL,
                      pos=6, bgColor=NULL, borderColor=NULL,
                      borderWidth=NULL, textStyle=NULL, subtextStyle=NULL, ...){
    # Work function for setTitle
    title <- ifnull(title, "")
    subtitle <- ifnull(subtitle, "")
    if (grepl("^\\[.+\\]\\(.+\\)$", title)){
        link <- gsub("^\\[(.+)\\]\\((.+)\\)$", "\\2", title)
        title <- gsub("^\\[(.+)\\]\\((.+)\\)$", "\\1", title)
    }
    if (grepl("^\\[.+\\]\\(.+\\)$", subtitle)){
        sublink <- gsub("^\\[(.+)\\]\\((.+)\\)$", "\\2", subtitle)
        subtitle <- gsub("^\\[(.+)\\]\\((.+)\\)$", "\\1", subtitle)
    }
    lstTitle <- list(text=title, subtext=subtitle)

    if (is.numeric(pos[[1]]) && pos[[1]] <= 12){
        lstTitle[c('x', 'y', 'orient')] <- vecPos(pos[[1]])
    }else if (length(pos)==3 && tolower(pos[[1]]) %in%
              c('left', 'right', 'center') &&
              tolower(pos[[2]]) %in% c('top', 'center', 'bottom') &&
              tolower(pos[[3]]) %in% c('vertical', 'horizontal')){
        lstTitle[c('x', 'y', 'orient')] <- pos
    }


    if (!is.null(link)) lstTitle[['link']] <- link
    if (!is.null(sublink)) lstTitle[['sublink']] <- sublink

    if (!is.null(bgColor)){
        if (bgColor != 'rgba(0,0,0,0)')
            lstTitle[['backgroundColor']] <- getColors(bgColor)[1]
    }
    if (!is.null(borderColor)){
        if (borderColor != '#ccc')
            lstTitle[['borderColor']] <- getColors(borderColor)[1]
    }
    if (!is.null(borderWidth)){
        if (borderWidth > 0)
            lstTitle[['borderWidth']] <- borderWidth
    }
    if (!is.null(textStyle)){
        if (!identical(textStyle, list(fontSize=18, fontWeight='bold', color='#333'))){
            if (all(names(textStyle) %in% c('fontSize', 'fontWeight', 'fontStyle',
                                            'color', 'fontFamily')))
                lstTitle[['textStyle']] <- textStyle
        }
    }
    if (!is.null(subtextStyle)){
        if (!identical(subtextStyle, list(color='#aaa'))){
            if (all(names(subtextStyle) %in% c('fontSize', 'fontWeight', 'fontStyle',
                                               'color', 'fontFamily')))
                lstTitle[['subtextStyle']] <- subtextStyle
        }
    }

    return(lstTitle)
}

#' Set \code{title} (And Subtitle) of Echarts
#'
#' When an echart object is generated, you can modify it by setting title and
#' subtitles using \code{\link{\%>\%}}.
#'
#' In echarts with timeline, you can set \code{title, subtitle, link, sublink, bgColor,
#' borderColor, borderWidth} as vectors of the same length as \code{z}. For \code{textSytle,
#' subtextStyle}, you need to pack the user-defined lists in a list.
#' @param chart \code{echarts} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param title text of the title. If written in markdown format \code{[caption](url)},
#' then \code{caption} is passed to title, \code{url} is passed to link. If the length
#' of the title vector equals to the length of timeline slices, the title vector will
#' be used as slice-specific user-defined title.
#' @param link link of the title
#' @param subtitle text of the subtitle. If written in markdown format \code{[caption](url)},
#' then \code{caption} is passed to title, \code{url} is passed to link. If the length
#' of the subtitle vector equals to the length of timeline slices, the subtitle vector will
#' be used as slice-specific user-defined title.
#' @param sublink link of the subtitle
#' @param pos the clock-position of title (and subtitle), refer to \code{\link{vecPos}}. Or
#' define a vector \code{c(x, y, orient)} yourself.
#' @param bgColor background color of title. Default 'rgba(0,0,0,0)' (transparent)
#' @param borderColor border color of the title. Default '#ccc'.
#' @param borderWidth border width of the title. Default 0px (not shown).
#' @param textStyle You can place self-defined textStyle list of the title here. E.g., \code{list(
#' fontFamily='Arial|Verdana|sans-serif', fontSize=20, fontWeight='normal|bold|bolder|lighter|<numbers>',
#' fontStyle='normal|italic|oblique', color='red')}
#' @param subtextStyle You can place self-defined textStyle of the subtitle here.
#' @param ... elipsis
#'
#' @return A modified echart object
#' @export
#'
#' @references
#' \url{http://echarts.baidu.com/echarts2/doc/option.html#title~title}
#'
#' @examples
#' \dontrun{
#' ## simple echarts scatter plot
#' g <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, series=Species, type='scatter')
#'
#' ## set simple titles
#' g %>% setTitle(title='Iris data set', subtitle='by: R. A. Fisher')
#'
#' ## set titles with links and textStyles
#' g %>% setTitle(
#'   '[Iris data set](https://en.wikipedia.org/wiki/Iris_flower_data_set)',
#'   '[R. A. Fisher](https://en.wikipedia.org/wiki/Ronald_Fisher)',
#'   textStyle=list(fontFamily='Courier New', fontSize=24, color='gold'),
#'   subtextStyle=list(color='silver'), bgColor='lightgreen')
#'
#'
#' ## echarts with timeline
#' g1 <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, z=Species, type='scatter')
#'
#' ## simple titles/subtitles
#' g1 %>% setTitle(
#'     '[Iris data set](https://en.wikipedia.org/wiki/Iris_flower_data_set)',
#'     '[R. A. Fisher](https://en.wikipedia.org/wiki/Ronald_Fisher)')
#'
#' ## user-defined titles/subtitles
#' titles <- c(
#'     '[Iris setosa](https://en.wikipedia.org/wiki/Iris_setosa)',
#'     '[Iris versicolor](https://en.wikipedia.org/wiki/Iris_versicolor)',
#'     '[Iris virginica](https://en.wikipedia.org/wiki/Iris_virginica)')
#'
#' g1 %>% setTitle(titles,
#'           textStyle=list(
#'               list(fontFamily='Impact', color='red', fontStyle='normal'),
#'               list(fontFamily='Times New Roman', color='green'),
#'               list(fontFamily='Calibri', color='blue', fontStyle='oblique')
#'           ),
#'        bgColor='lightyellow')
#'   ## textStyle is a list length 3, mapping 3 levels for timeline
#' }
setTitle <- function(chart, title=NULL, subtitle=NULL, link=NULL, sublink=NULL,
                     pos=6, bgColor=NULL, borderColor=NULL, borderWidth=NULL,
                     textStyle=NULL, subtextStyle=NULL, ...){
    stopifnot(inherits(chart, 'echarts'))
    hasZ <- 'timeline' %in% names(chart$x)
    if (hasZ){  # has a timeline
        if (!is.null(title)){
            if (length(title) == length(chart$x$options)){
                titles <- unlist(title)
            } else {
                if (grepl("^\\[.+\\]\\(.+\\)$", title[1])){
                    link <- gsub("^\\[(.+)\\]\\((.+)\\)$", "\\2", title[1])
                    title <- gsub("^\\[(.+)\\]\\((.+)\\)$", "\\1", title[1])
                }
                titles <- paste0(
                    rep(gsub("^\\[(.+)\\]\\((.+)\\)$", "\\1", title),
                        length(chart$x$options)), " (",
                    attr(chart$x$timeline, 'sliceby'), " = ",
                    chart$x$timeline$data, ")")
            }
        }else{
            titles <- rep(NULL, length(chart$x$options))
        }
        .dupicateThem <- function(val){
            if (!is.null(val)){
                if ((is.list(val) && is.list(val[[1]])) || is.vector(val)){
                    if (length(val) == length(chart$x$options)){
                        return(val)
                    }else{
                        return(rep(val[1], length(chart$x$options)))
                    }
                }else{
                    if (is.list(val))
                        return(rep(list(val[1]), length(chart$x$options)))
                    else
                        return(rep(val[1], length(chart$x$options)))
                }
            }else{
                return(rep(NULL, length(chart$x$options)))
            }
        }
        subtitles <- .dupicateThem(subtitle)
        links <- .dupicateThem(link)
        sublinks <- .dupicateThem(sublink)
        bgColors <- .dupicateThem(bgColor)
        borderColors <- .dupicateThem(borderColor)
        borderWidths <- .dupicateThem(borderWidth)
        textStyles <- .dupicateThem(textStyle)
        subtextStyles <- .dupicateThem(subtextStyle)

        if (! all(is.null(c(titles, subtitles, links, sublinks, bgColor,
                            borderColor, borderWidth, textStyle, subtextStyle)))) {
            for (i in seq_len(length(chart$x$options))){
                chart$x$options[[i]][['title']] <- makeTitle(
                    title=titles[i], subtitle=subtitles[i], link=links[i],
                    sublink=sublinks[i], pos=pos, bgColor=bgColors[i],
                    borderColor=borderColors[i], borderWidth=borderWidths[i],
                    textStyle=textStyles[[i]], subtextStyle=subtextStyles[[i]]
                )
            }
        }
    }else{  # do not have timeline
        if (! all(is.null(c(title, subtitle, link, sublink))))
            chart$x$title <- makeTitle(
                title=title, subtitle=subtitle, link=link, sublink=sublink,
                pos=pos, borderColor=borderColor, borderWidth=borderWidth,
                bgColor=bgColor, textStyle=textStyle, subtextStyle=subtextStyle
            )
    }
    return(chart %>% tuneGrid())
}

makeToolbox <- function(toolbox=c(TRUE,'cn'), type='auto',
                        show=c('mark', 'dataZoom', 'dataView', 'magicType',
                               'restore', 'saveAsImage'), pos=1,
                        bgColor='rgba(0,0,0,0)', borderColor='#ccc', borderWidth=0,
                        padding=5, itemGap=10, itemSize=16,
                        color=c("#1e90ff", "#22bb22", "#4b0082", "#d2691e"),
                        disableColor='#ddd', effectiveColor='red', showTitle=TRUE,
                        textStyle=NULL,
...){
    # Work function for setToolbox

    if (! is.null(show)) show <- tolower(show)
    if (toolbox[1]){
        lstToolbox= list(
            show = ifnull(as.logical(toolbox[1]), TRUE),
            feature = list(
                mark =list(show = ('mark' %in% show)),
                dataZoom = list(show = ('datazoom' %in% show)),
                dataView = list(show = ('dataview' %in% show),
                                readOnly = FALSE),
                magicType = list(show = FALSE),
                restore = list(show = ('restore' %in% show)),
                saveAsImage = list(show = ('saveasimage' %in% show))
            )
        )
        if (! missing(bgColor)) if (bgColor != 'rgba(0,0,0,0)')
            lstToolbox$backgroundColor <- bgColor
        if (! missing(borderColor)) if (borderColor != '#ccc')
            lstToolbox$borderColor <- borderColor
        if (! missing(borderWidth)) if (borderWidth > 0)
            lstToolbox$borderWidth <- borderWidth
        if (! missing(padding)) if (padding != 5) lstToolbox$padding <- padding
        if (! missing(itemGap)) if (itemGap != 10)
            lstToolbox$itemGap <- itemGap
        if (! missing(itemSize)) if (itemSize != 16) lstToolbox$itemSize <- itemSize
        if (! missing(color)) if (!identical(color, c("#1e90ff", "#22bb22", "#4b0082", "#d2691e")))
            lstToolbox$color <- color
        if (! missing(disableColor)) if (disableColor != '#ddd')
            lstToolbox$disableColor <- disableColor
        if (! missing(effectiveColor)) if (effectiveColor != 'red')
            lstToolbox$effectiveColor <- effectiveColor
        if (! missing(showTitle)) if (! showTitle) lstToolbox$showTitle <- showTitle
        if (! missing(textStyle)) if (is.null(textStyle))
            lstToolbox$textStyle <- textStyle

        if (tolower(toolbox[2]) != 'cn'){  # Enlish tooltips of the controls
            lstToolbox[['feature']][['mark']][['title']] = list(
                mark="Apply Auxiliary Conductor",
                markUndo="Undo Auxiliary Conductor",
                markClear="Clear Auxiliary Conductor")
            lstToolbox[['feature']][['dataZoom']][['title']] = list(
                dataZoom="Data Zoom",
                dataZoomReset="Reset Data Zoom")
            lstToolbox[['feature']][['dataView']][['title']] = "Data View"
            lstToolbox[['feature']][['dataView']][['lang']] <-
                c('Data View', 'Close', 'Refresh')
            lstToolbox[['feature']][['restore']][['title']] = "Restore"
            lstToolbox[['feature']][['saveAsImage']][['title']] = "Save As Image"
            lstToolbox[['feature']][['saveAsImage']][['lang']] <- 'Click to Save'
        }

        if (is.numeric(pos[[1]]) && pos[[1]] <= 12){
            lstToolbox[c('x', 'y', 'orient')] <- vecPos(pos[[1]])
        }else if (length(pos)==3 && tolower(pos[[1]]) %in%
                  c('left', 'right', 'center') &&
                  tolower(pos[[2]]) %in% c('top', 'center', 'bottom') &&
                  tolower(pos[[3]]) %in% c('vertical', 'horizontal')){
            lstToolbox[c('x', 'y', 'orient')] <- pos
        }

        if (type[1] %in% c('auto', 'line', 'bar', 'k')){
            lstToolbox[['feature']][['magicType']] <-
                list(show=TRUE, type= c('line', 'bar', 'tiled', 'stack'))
        }else if (type[1] %in% c('pie', 'funnel')){
            lstToolbox[['feature']][['magicType']] <-
                list(show=TRUE, type= c('pie', 'funnel'))
        }else if (type[1] %in% c('force', 'chord')){
            lstToolbox[['feature']][['magicType']] <-
                list(show=TRUE, type= c('force', 'chord'))
            lstToolbox[['feature']][['dataView']] <- list(show=FALSE)
            lstToolbox[['feature']][['dataZoom']] <- list(show=FALSE)
        }
        if (lstToolbox$feature$magicType$show){
            if (tolower(toolbox[2]) != 'cn'){
                lstToolbox[['feature']][['magicType']][['title']] <- list(
                    line   = "Switch to Line Chart",
                    bar    = "Switch to Bar Chart",
                    stack  = "Stack",
                    tiled  = "Tiled",
                    force  = "Switch to Force Chart",
                    chord  = "Switch to Chord Chart",
                    pie    = "Switch to Pie Chart",
                    funnel = "Switch to Funnel Chart"
                )
            }
        }
    }else{
        lstToolbox=list(show=FALSE)
    }
    return(lstToolbox)
}

#' Set \code{toolbox} of Echarts
#'
#' When an echart object is generated, you can modify it by setting toolbox using
#' \code{\link{\%>\%}}.
#'
#' @param chart \code{echarts} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param show logical. Show the toolbox if TRUE.
#' @param language 'cn' or 'en', the language of the toolbox tooltips.
#' @param controls which widgets to show. Default \code{'mark', 'dataZoom', 'dataView', 'magicType',
#' 'restore', 'saveAsImage'}.
#' @param pos the clock-position of toolbox, refer to \code{\link{vecPos}}. Or you can
#' define a vector \code{c(x, y, orient)} yourself.#'
#' @param bgColor background color, default transparent ('rgba(0,0,0,0)').
#' @param borderColor border color, default '#ccc'.
#' @param borderWidth border width, default 0px (not shown).
#' @param padding Padding of the toolbox. Default 5px. Could also be a list assigning
#' padding of top, right, bottom and left.
#' @param itemGap Gap between the items. Default 10px.
#' @param itemSize Size of the items. Default 16px.
#' @param color Colors of the toolbox widgets (applied in loops). Default
#' c("#1e90ff", "#22bb22", "#4b0082", "#d2691e").
#' @param disableColor Color for disabled widgets. Default '#ddd'.
#' @param effectiveColor Color for widgets be triggered. Default 'red'.
#' @param showTitle Logical, if widgets title are shown. Default TRUE.
#' @param textStyle A list of the text style of the widgets. Default \code{
#' list(fontFamily=c('Arial, Verdana, sans-serif'), fontSize=12, fontStyle='normal',
#' fontWeight='normal')}
#' @param ... elipsis
#'
#' @return A modified echart object
#' @export
#'
#' @references \url{http://echarts.baidu.com/echarts2/doc/option.html#title~toolbox}
#' @examples
#' \dontrun{
#' g <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, series=Species, type='scatter')
#' g %>% setToolbox(TRUE, 'en')
#' }
setToolbox <- function(chart, show=TRUE, language='cn',
                       controls=c('mark', 'dataZoom', 'dataView', 'magicType',
                                  'restore', 'saveAsImage'), pos=1,
                       bgColor='rgba(0,0,0,0)', borderColor='#ccc', borderWidth=0,
                       padding=5, itemGap=10, itemSize=16,
                       color=c("#1e90ff", "#22bb22", "#4b0082", "#d2691e"),
                       disableColor='#ddd', effectiveColor='red', showTitle=TRUE,
                       textStyle=NULL,
...){
    stopifnot(inherits(chart, 'echarts'))
    hasZ <- 'timeline' %in% names(chart$x)
    if (hasZ){
        type <- chart$x$options[[1]]$series[[1]]$type
        chart$x$options[[1]]$toolbox <- makeToolbox(
            toolbox=c(show, language), type, controls, pos, bgColor,
            borderColor, borderWidth, padding, itemGap, itemSize, color,
            disableColor, effectiveColor, showTitle, textStyle)
    }else{
        type <- chart$x$series[[1]]$type
        chart$x$toolbox <- makeToolbox(
            toolbox=c(show, language), type, controls, pos, bgColor,
            borderColor, borderWidth, padding, itemGap, itemSize, color,
            disableColor, effectiveColor, showTitle, textStyle)
    }

    return(chart %>% tuneGrid())
}

#-----Palettes and others---------
#' Get The Colors Vector From A Named Palette
#'
#' Get hex color vector of a named palette from \code{\link{RColorBrewer}}, \code{\link{ggthemes}}
#' or \code{\link{grDevices}}. You can \code{\link{show_col}} the vector to
#' see the effects.
#' @param palname name of the palette. Default NULL to get echarts default. Could be:
#' \itemize{
#'  \item \link{RColorBrewer} palettes: Including \code{'BrBG', 'PiYG', 'PRGn', 'PuOr', 'RdBu',
#'  'RdGy', 'RdYlBu', 'RdYlGn', 'Spectral', 'Accent', 'Dark2', 'Paired', 'Pastel1',
#'  'Pastel2', 'Set1', 'Set2', 'Set3', 'Blues', 'BuGn', 'BuPu', 'GnBu', 'Greens',
#'  'Greys', 'Oranges', 'OrRd', 'PuBu', 'PuBuGn', 'PuRd', 'Purples', 'RdPu', 'Reds',
#'  'YlGn', 'YlGnBu', 'YlOrBr', 'YlOrRd'} \cr
#'  \item \link{ggthemes} palettes: \code{'calc', 'economist', 'economist_white', 'economist_stata',
#'  'excel', 'exel_fill', 'excel_line', 'excel_new', 'few', 'fivethirtyeight', '538', 'manyeyes',
#'  'gdocs', 'pander', 'tableau', 'stata', 'stata1','stata1r','statamono', 'ptol',
#'  'tableau20', 'tableau10medium', 'tableaugray', 'tableauprgy', 'tableaublrd',
#'  'tableaugnor', 'tableaucyclic', 'tableau10light', 'tableaublrd12', 'tableauprgy12',
#'  'tableaugnor12', 'hc', 'darkunica', 'solarized', 'solarized_red', 'solarized_yellow',
#'  'solarized_orange', 'solarized_magenta', 'solarized_violet', 'solarized_blue',
#'  'solarized_cyan', 'solarized_green', 'wsj', 'wsj_rgby', 'wsj_red_green',
#'  'wsj_black_green', 'wsj_dem_rep', 'colorblind', 'trafficlight'} \cr
#'  \item Aetna official palettes: Including \code{'aetnagreen', 'aetnablue', 'aetnaviolet',
#'  'aetnaorange', 'aetnateal', 'aetnacranberry'} \cr
#'  \item Other palettes: \code{'rainbow', 'terrain', 'topo', 'heat', 'cm'}
#' }
#' @param n length of the color vector when the palette is continuous (\code{rain, cm,
#' terrain, topo, heat, ...}). Default 6.
#' @import RColorBrewer scales ggthemes
#' @export
#' @return color vectors
#'
#' @seealso \code{\link{RColorBrewer}}, \code{\link{scales}}, \code{\link{ggthemes}},
#' \code{\link{show_col}}
#' @examples
#' \dontrun{
#' library(scales)
#' show_col(getColFromPal('tableau20'))
#' show_col(getColFromPal('hc'))
#' }
getColFromPal <- function(palname=NULL, n=6){
    brewer <- c('BrBG', 'PiYG', 'PRGn', 'PuOr', 'RdBu', 'RdGy', 'RdYlBu',
                'RdYlGn', 'Spectral', 'Accent', 'Dark2', 'Paired', 'Pastel1',
                'Pastel2', 'Set1', 'Set2', 'Set3', 'Blues', 'BuGn', 'BuPu',
                'GnBu', 'Greens', 'Greys', 'Oranges', 'OrRd', 'PuBu', 'PuBuGn',
                'PuRd', 'Purples', 'RdPu', 'Reds', 'YlGn', 'YlGnBu', 'YlOrBr',
                'YlOrRd')
    tableau <- data.frame(
        nick=c('tableau20', 'tableau10medium', 'tableaugray', 'tableauprgy',
               'tableaublrd', 'tableaugnor', 'tableaucyclic', 'tableau10light',
               'tableaublrd12', 'tableauprgy12', 'tableaugnor12', 'tableau',
               'tableaucolorblind', 'trafficlight'),
        pal=c('tableau20', 'tableau10medium', 'gray5', 'purplegray6',
              'bluered6', 'greenorange6', 'cyclic', 'tableau10light',
              'bluered12', 'purplegray12', 'greenorange12', 'tableau10',
              'colorblind10', 'trafficlight'))
    ## echarts default
    colObj <- c('#ff7f50', '#87cefa', '#da70d6', '#32cd32', '#6495ed',
                '#ff69b4', '#ba55d3', '#cd5c5c', '#ffa500', '#40e0d0',
                '#1e90ff', '#ff6347', '#7b68ee', '#00fa9a', '#ffd700',
                '#6b8e23', '#ff00ff', '#3cb371', '#b8860b', '#30e0e0' )
    if (! is.null(palname)) palname <- tolower(palname)
    if (! is.null(palname)){
        if (palname %in% paste0(
            "aetna", c('green','blue','teal','cranberry','orange','violet'))){
            colObj <- switch(
                palname,
                aetnagreen=c("#7AC143", "#7D3F98", "#F47721", "#D20962",
                             "#00A78E", "#00BCE4", "#B8D936", "#EE3D94",
                             "#FDB933", "#F58F9F", "#60C3AE", "#5F78BB",
                             "#5E9732", "#CEA979", "#EF4135", "#7090A5"),
                aetnablue=c("#00BCE4", "#D20962", "#7AC143", "#F47721",
                            "#7D3F98", "#00A78E", "#F58F9F", "#B8D936",
                            "#60C3AE", "#FDB933", "#EE3D94", "#5E9732",
                            "#5F78BB", "#CEA979", "#EF4135", "#7090A5"),
                aetnateal=c("#00A78E", "#F47721", "#7AC143", "#00BCE4",
                            "#D20962", "#7D3F98", "#60C3AE", "#FDB933",
                            "#B8D936", "#5F78BB", "#F58F9F", "#EE3D94",
                            "#5E9732", "#CEA979", "#EF4135", "#7090A5"),
                aetnacranberry=c("#D20962", "#00BCE4", "#7D3F98", "#7AC143",
                                 "#F47721", "#00A78E", "#F58F9F", "#60C3AE",
                                 "#EE3D94", "#B8D936", "#FDB933", "#5E9732",
                                 "#5F78BB", "#CEA979", "#EF4135", "#7090A5"),
                aetnaorange=c("#F47721", "#7AC143", "#00A78E", "#D20962",
                              "#00BCE4", "#7D3F98", "#FDB933", "#B8D936",
                              "#60C3AE", "#F58F9F", "#5F78BB", "#EE3D94",
                              "#5E9732", "#CEA979", "#EF4135", "#7090A5"),
                aetnaviolet=c("#7D3F98", "#7AC143", "#F47721", "#00A78E",
                              "#00BCE4", "#D20962", "#F58F9F", "#B8D936",
                              "#FDB933", "#60C3AE", "#5F78BB", "#EE3D94",
                              "#5E9732", "#CEA979", "#EF4135", "#7090A5")
            )
        }else if (palname %in% tolower(brewer)){
            Palname <- brewer[which(tolower(brewer)==palname)]
            maxcolors <- brewer.pal.info[row.names(brewer.pal.info)==Palname,
                                         "maxcolors"]
            colObj <- brewer.pal(ifelse((maxcolors>n && n>2), n, maxcolors),
                                 Palname)
        }else{
            if (palname %in% c('rainbow', 'terrain', 'topo', 'heat', 'cm')){
                colObj <- switch(palname,
                                 rainbow=substr(rainbow(n), 1, 7),
                                 terrain=substr(terrain.colors(n), 1, 7),
                                 heat=substr(heat.colors(n), 1, 7),
                                 topo=substr(topo.colors(n), 1, 7),
                                 cm=substr(cm.colors(n), 1, 7)
                )
            }else{
                if (palname %in% c('pander')){
                    colObj <- palette_pander(n)
                }else if (palname %in% c('calc')){
                    colObj <- ggthemes:::ggthemes_data$calc$colors
                }else if (palname %in% c('ptol')) {
                    colObj <- ptol_pal()(ifelse(n > 12, 12, n))
                }else if (palname %in% c('excel', "excel_fill", "excel_line",
                                         "excel_new")){
                    palname <- unlist(strsplit(palname, "excel_"))[2]
                    if (is.na(palname)) palname <- 'new'
                    colObj <- ggthemes:::ggthemes_data$excel[[palname]]
                }else if (palname %in% c('economist', 'economist_white',
                                         'economist_stata')){
                    palname <- unlist(strsplit(palname,"economist_"))[2]
                    if (is.na(palname) || palname=='white') {
                        colObj <- ggthemes:::ggthemes_data$economist$fg
                    } else {
                        colObj <- ggthemes:::ggthemes_data$economist$stata$fg
                    }
                }else if (palname %in% c('darkunica', 'hc')){
                    palname <- ifelse(palname == 'hc', 'default', palname)
                    colObj <- ggthemes:::ggthemes_data$hc$palettes[[palname]]
                }else if (palname %in% c('wsj', 'wsj_rgby', 'wsj_red_green',
                                         'wsj_black_green', 'wsj_dem_rep')){
                    palname <- unlist(strsplit(palname,"wsj_"))[2]
                    if (is.na(palname)) palname <- 'colors6'
                    colObj <- ggthemes:::ggthemes_data$wsj$palettes[[palname]]
                }else if (palname %in% c('stata', 'stata1', 'stata1r', 'statamono')){
                    palname <- switch(palname, stata='stata', stata1='s1color',
                                      stata1r='s1rcolor', statamono='mono')
                    if (palname == 'stata'){
                        colObj <- ggthemes:::ggthemes_data$stata$colors
                    }else{
                        colObj <- try(eval(parse(text=paste0(
                            "stata_pal('", palname, "')(15)"))), TRUE)
                    }
                }else if (palname %in% c('few', 'few_dark', 'few_light')){
                    palname <- unlist(strsplit(palname,"few_"))[2]
                    if (is.na(palname)) palname <- "medium"
                    colObj <- ggthemes:::ggthemes_data$few[[palname]]
                }else if (palname %in%
                          c('fivethirtyeight','gdocs', 'colorblind', 'manyeyes',
                            '538')){
                    if (palname == '538') palname <- 'fivethirtyeight'
                    colObj <- ggthemes:::ggthemes_data[[palname]]
                }else if (palname %in%
                          c('tableau20', 'tableau10medium', 'tableaugray', 'tableauprgy',
                            'tableaublrd', 'tableaugnor', 'tableaucyclic', 'tableau10light',
                            'tableaublrd12', 'tableauprgy12', 'tableaugnor12', 'tableau',
                            'tableaucolorblind', 'trafficlight')){
                    palname <- tableau[tableau$nick==palname,"pal"]
                    colObj <- try(eval(parse(text=paste0("tableau_color_pal(palette='",
                                                         palname,"')(20)"))), TRUE)
                }else if (palname %in%
                          c('solarized', 'solarized_red', 'solarized_yellow',
                            'solarized_orange', 'solarized_magenta', 'solarized_violet',
                            'solarized_blue', 'solarized_cyan', 'solarized_green')){
                    palname <- unlist(strsplit(palname,"solarized_"))[2]
                    colObj <- try(eval(parse(text=paste0(
                        "solarized_pal('", ifnull(palname, 'blue'), "')(20)"))), TRUE)
                }
            }
        }
    }
    return(as.vector(colObj))
}

#' Get Hex Color Vector (Not Exported)
#'
#' Get color vector from a palette/color name. It is wider than \code{\link{getColFromPal}}.
#' @param palette Palette, default NULL. Could be
#' \itemize{
#'  \item palette name, e.g, "Blues". The palette will be proceeded by \code{\link{getColFromPal}}.
#'  \item a hex color, e.g., "#FFFFFF", "0xFFFFFFFF"
#'  \item a vector or color names, hex colors
#'  \item NULL
#' }
#' @param ... Elipsis
#'
#' @return A vector of hex colors
#'
#' @seealso \code{\link{getColFromPal}} \code{\link{RColorBrewer}} \code{\link{ggthemes}}
#' @examples
#' \dontrun{
#' library(scales)
#' show_col(getColors(NULL))
#' show_col(getColors("terrain"))
#' show_col(getColors(c('red', 'gold', 'skyblue')))
#' }
getColors <- function(palette, ...){
    # build a function to extract palette info
    # used for echartR
    if ("n" %in% names(list(...))) n <- list(...)[['n']] else n <- 6
    if (length(palette)==1) {
        if (substr(palette, 1, 1)=="#"){
            if (nchar(palette) == 7 || nchar(palette) == 4) {
                return(palette)
            }else{
                palette <- paste0('0x', substring(palette, seq(2,8,2), seq(3,9,2)))
                palette <- strtoi(palette)
                return(rgba(palette))
            }
        }else if (palette %in% colors()){
            return(substr(col2hcl(palette), 1, 7))
        }else if (grepl('^rgba\\(', palette)){
            return(palette)
        }else{
            palettes <- unlist(strsplit(palette, "[\\(\\)]", perl=TRUE))
            if (length(palettes)==1){
                return(getColFromPal(palettes[1], n))
            }else{
                aetPal <- getColFromPal(palettes[1], as.numeric(palettes[2]))
                if (as.numeric(palettes[2]) < length(aetPal)){
                    return(sample(aetPal, as.numeric(palettes[2])))
                }else{
                    return(aetPal)
                }
            }
        }
    }else if(length(palette)>1){
        .convCol <- function(iPal){
            if (!is(try(col2rgb(iPal), TRUE), "try-error")){
                if (substr(iPal, 1, 1) == "#"){
                    return(toupper(iPal))
                }else{
                    vecCol <- as.vector(col2rgb(iPal))
                    return(rgba(vecCol))
                }
            }
        }
        aetPal <- unlist(lapply(palette, .convCol))
        return(aetPal)
    }else{
        return(getColFromPal(NULL))
    }
}

makeDataZoom <- function(show=FALSE, pos=6, range=NULL, width=30,
                         fill='rgba(144,197,237,0.2)',
                         handle='rgba(70,130,180,0.8)',
                         bgColor = 'rgba(0,0,0,0)',
                         dataBgColor = '#eee', showDetail=TRUE, realtime=FALSE,
                         zoomLock=FALSE,
...){
    # Work function for setDataZoom
    if (is.numeric(pos[1])) pos <- vecPos(pos)
    if (!is.null(show)) {
        lstdataZoom <- list(show=show)
        if (! missing(fill)) if (fill != 'rgba(144,197,237,0.2)')
            lstdataZoom$fillerColor <- fill
        if (! missing(handle)) if (handle != 'rgba(70,130,180,0.8)')
            lstdataZoom$handleColor <- handle
        if (! missing(bgColor)) if (bgColor != 'rgba(0,0,0,0)')
            lstdataZoom$backgroundColor <- bgColor
        if (! missing(dataBgColor)) if (dataBgColor != '#eee')
            lstdataZoom$dataBackgroundColor <- dataBgColor
        if (! missing(showDetail)) if (!showDetail)
            lstdataZoom$showDetail <- showDetail
        if (! missing(realtime)) if (realtime)
            lstdataZoom$realtime <- realtime
        if (! missing(zoomLock)) if (zoomLock)
            lstdataZoom$zoomLock <- zoomLock

        if (pos[[3]] == 'vertical'){
            lstdataZoom[['y']] <- 60
            if (pos[[1]]=='left') lstdataZoom[['x']] <- 0
            if (pos[[1]]=='right') lstdataZoom[['x']] <- dev.size('px')[1] - 80
        }else{
            if (! (pos[[1]] == 'center' && pos[[2]] == 'bottom')){
                lstdataZoom[['x']] <- 80
                if (pos[[2]]=='top') lstdataZoom[['y']] <- 0
            }
        }

        lstdataZoom[['orient']] <- pos[[3]]
        if (lstdataZoom$orient == 'horizontal') lstdataZoom[['height']] <- width
        if (lstdataZoom$orient == 'vertical') lstdataZoom[['width']] <- width

        if (!is.null(range))
            range <- c(range[1], ifelse(length(range) == 1, range[1], range[2]))
        if (all(is.numeric(range[1:2]))){
            if (any(! range >= 0 | ! range <= 100)){
                stop("dataZoom should be between 0 and 100")
            }else{
                lstdataZoom[['start']] <- min(range[1:2])
                lstdataZoom[['end']] <- max(range[1:2])
            }
        }
    } else {
        lstdataZoom <- list(show=FALSE)
    }
    return(lstdataZoom)
}

#' Set \code{dataZoom} Bar of Echarts
#'
#' When an echart object is generated, you can modify it by setting dataZoom using
#' \code{\link{\%>\%}}.
#'
#' @param chart \code{echarts} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param show logical. Show the dataZoom control if TRUE.
#' @param pos the clock-position of dataZoom, refert to \code{\link{vecPos}}. You can
#' define a vector \code{c(x, y, orient)} yourself.
#' @param range A vector of \code{c(min, max)}. Cannot be out of the frame c(0, 100)
#' @param width The width of the dataZoom bar. Default 20px.
#' @param fill fillerColor of the dataZoom bar, in character \code{'rgba(red, green,
#' blue, alpha)'} format. Default 'rgba(144,197,237,0.2)' ("#90C5ED33").
#' @param handle handleColor of the dataZoom bar, in character \code{'rgba(red, green,
#' blue, alpha)'} format. Default 'rgba(70,130,180,0.8)' ("#4682B4CC").
#' @param bgColor background color. Default transparent ('rgba(0,0,0,0)')
#' @param dataBgColor background color of the data thumbnail (1st series). Default
#' '#eee'.
#' @param showDetail Logical, if show the details when zooming. Defaul TRUE.
#' @param realtime Logical, if realtime display the changes when zooming. Default FALSE.
#' @param zoomLock Logical, if the zoom range is locked. Deafult FALSE.
#' @param ... Elipsis
#' @return A modified echart object
#' @export
#'
#' @references \url{http://echarts.baidu.com/echarts2/doc/option.html#title~dataZoom}
#' @examples
#' \dontrun{
#' g <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, series=Species, type='scatter')
#' g %>% setDataZoom(fill=rgba(c(col2rgb('gold'), 0.3)),
#'                   handle=rgba(c(col2rgb('gold'), 1)))
#'
#' g1 <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, z=Species, type='scatter')
#' g1 %>% setDataZoom(fill=rgba(c(col2rgb('lightgreen'), 0.2)),
#'                   handle=rgba(c(col2rgb('darkgreen'), 0.5)))
#' }
setDataZoom <- function(chart, show=TRUE, pos=6, range=NULL, width=30,
                        fill='rgba(144,197,237,0.2)',
                        handle='rgba(70,130,180,0.8)', bgColor = 'rgba(0,0,0,0)',
                        dataBgColor = '#eee', showDetail=TRUE, realtime=FALSE,
                        zoomLock=FALSE, ...){
    stopifnot(inherits(chart, 'echarts'))
    hasZ <- 'timeline' %in% names(chart$x)
    if (hasZ){
        chart$x$options[[1]][['dataZoom']] <- makeDataZoom(
            show=show, pos=pos, range=range, fill=fill, handle=handle,
            backgroundColor=bgColor, dataBackgroundColor=dataBgColor,
            showDetail=showDetail, realtime=realtime, zoomLock=zoomLock
        )
    }else{
        chart$x[['dataZoom']] <- makeDataZoom(
            show=show, pos=pos, range=range, fill=fill, handle=handle,
            backgroundColor=bgColor, dataBackgroundColor=dataBgColor,
            showDetail=showDetail, realtime=realtime, zoomLock=zoomLock)
    }

    return(chart %>% tuneGrid())
}

makeDataRange <- function(show=FALSE, pos=8, min=NULL, max=NULL, splitNumber=5,
                          itemGap=5, labels=NULL, calculable=FALSE,
                          borderColor='#ccc', borderWidth=0,
                          selectedMode=list(TRUE, 'single', 'multiple'),
                          color=c("#1e90ff", "#f0ffff"),
                          splitList=NULL, initialRange=NULL,
...){
    # Work function for setDataRange
    ## color must be color vector
    ## splitList must be list(list(start=m, end=n, label=x, color=hex), ...)
    ## initialRange must be list(start=m, end=n)
    if (is.null(show)) {
        lstdataRange <- NULL
    } else {
        if (! show){
            lstdataRange <- NULL
        }else{
            lstdataRange <- list(
                show=show, calculable=ifelse(
                    as.numeric(splitNumber[1])==0 || is.null(splitNumber),
                    calculable, FALSE),
                itemWidth=6, selectedMode=selectedMode[[1]]
            )

            if (is.numeric(pos[[1]]) && pos[[1]] <= 12){
                lstdataRange[c('x', 'y', 'orient')] <- vecPos(pos[[1]])
            }else if (length(pos)==3 && tolower(pos[[1]]) %in%
                      c('left', 'right', 'center') &&
                      tolower(pos[[2]]) %in% c('top', 'center', 'bottom') &&
                      tolower(pos[[3]]) %in% c('vertical', 'horizontal')){
                lstdataRange[c('x', 'y', 'orient')] <- pos
            }

            if (!missing(color)) if (! identical(color, c("#1e90ff", "#f0ffff")))
                lstdataRange[['color']] <- color
            if (!missing(borderColor)) if (borderColor != '#ccc')
                lstdataRange[['borderColor']] <- borderColor
            if (!missing(borderWidth)) if (borderWidth > 0)
                lstdataRange[['borderWidth']] <- borderWidth

            if (!missing(labels)) if (!is.null(labels)) {
                if (length(labels) == 1) lstdataRange[['text']] <- c(labels, "")
                else lstdataRange[['text']] <- labels[1:2]
            }
            if (!missing(min)) if (!is.null(min))
                lstdataRange[['min']] <- as.numeric(min)
            if (!missing(max)) if (!is.null(max))
                lstdataRange[['max']] <- as.numeric(max)
            if (!missing(splitList)) if (!is.null(splitList)){
                if (is.list(splitList) &&
                    all(names(splitList[[1]]) %in% c('start', 'end', 'label', 'color'))){
                    lstdataRange[['splitList']] <- splitList
                    lstdataRange[['itemGap']] <- itemGap
                }
            }else{
                if (splitNumber > 0) {
                    lstdataRange[['itemGap']] <- itemGap
                    lstdataRange[['splitNumber']] <- splitNumber
                }
            }
            if (calculable && !is.null(initialRange)){
                if (is.list(initialRange) &&
                    all(names(initialRange) %in% c('start', 'end'))){
                    lstdataRange[['range']] <- initialRange
                }
            }
        }
    }
    return(lstdataRange)
}

#' Set \code{dataRange} Bar of Echarts
#'
#' When an echart object is generated, you can modify it by setting dataRange using
#' \code{\link{\%>\%}}.
#'
#' @param chart \code{echarts} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param show logical. Show the dataRange control if TRUE.
#' @param pos the clock-position of dataRange, default 8. Refer to \code{\link{vecPos}}.
#' Or you can define the position vector \code{c(x, y, orient)} yourself.
#' @param valueRange The range of the dataRange bar in form of \code{c(min, max)}.
#' If NULL, echarts default will be used.
#' @param splitNumber How many discrete sections will the dataRange bar be divided into.
#' Default 5. Set it to 0 to set the bar continuous.
#' @param itemGap The gap between itmes in pixels. Default 10px.
#' @param labels The labels to the ends the dataRange bar in form \code{c('high end',
#' 'low end')}. Default NULL, the min, max values will be used.
#' @param borderColor The border color of the dataRange bar. Default '#333'.
#' @param borderWidth The border width of the dataRange bar. Default 0px (not shown).
#' @param calculable Logical. If echart calculable feature is open. Default FALSE.
#' @param selectedMode The mode of the dataRange bar, default TRUE. You can also
#' set it 'single' or 'multiple'.
#' @param color The hex vector of colors used for dataRange bar. Default c("#1e90ff", "#f0ffff").
#' @param splitList A list for user-defined value split in the form of
#' \code{list(list(start=m, end=n, label=x, color=hex), ...)}. If a valid splitList is set,
#' splitNumber will be disabled.
#' @param initialRange Initial selected value range in the form of \code{list(start=m, end=n)}
#' @param ... Elipsis
#'
#' @return A modified echarts object
#' @export
#'
#' @references \url{http://echarts.baidu.com/echarts2/doc/option.html#title~dataRange}
#' @examples
#' \dontrun{
#' g <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, series=Species, type='scatter')
#' g %>% setDataRange()
#'
#' g1 <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, z=Species, type='scatter')
#' g1 %>% setDataRange(valueRange=c(0, 2.5))
#' }
setDataRange <- function(
    chart, show=TRUE, pos=8, valueRange=NULL, splitNumber=5, itemGap=5,
    labels=NULL, calculable=FALSE, borderColor='#ccc', borderWidth=0,
    selectedMode=list(TRUE, 'single', 'multiple'),
    color=c("#1e90ff", "#f0ffff"), splitList=NULL, initialRange=NULL,
...){
    stopifnot(inherits(chart, 'echarts'))
    hasZ <- 'timeline' %in% names(chart$x)
    if (! is.null(valueRange[1])) {
        if (is.numeric(valueRange) && length(valueRange) > 1){
            min <- range(valueRange)[1]
            max <- range(valueRange)[2]
        }else{
            min <- max <- NULL
        }
    }else{
        min <- range(getYFromEChart(chart))[1]
        max <- range(getYFromEChart(chart))[2]
    }

    lst <- makeDataRange(
        show=show, pos=pos, min=min, max=max, splitNumber=splitNumber,
        itemGap=itemGap, labels=labels, calculable=calculable,
        borderColor=borderColor, borderWidth=borderWidth, selectedMode=selectedMode,
        color=color, splitList=splitList, initialRange=initialRange
    )
    if (!is.null(lst)){
        if (hasZ){
            chart$x$options[[1]][['dataRange']] <- lst
        } else {
            chart$x[['dataRange']] <- lst
        }
    }

    return(chart %>% tuneGrid())
}

getYFromEChart <- function(chart, ...){
    ## get y series data and extract the unique values vector
    stopifnot(inherits(chart, 'echarts'))
    hasZ <- 'timeline' %in% names(chart$x)
    .getY <- function(seriesData){
        if (! is.null(dim(seriesData))){
            if (dim(seriesData)[2] > 1){
                return(seriesData[,2])
            }else{
                return(seriesData[,1])
            }
        }else{
            return(seriesData)
        }
    }
    if (hasZ){
        y <- sapply(chart$x$options, function(lst){
            Ys <- sapply(lst$series, function(l) {
                return(.getY(l$data))
            })
            return(Ys)
        })
    }else{
        y <- sapply(chart$x$series, function(lst) {
            return(.getY(lst$data))
        })
    }
    return(as.numeric(unique(unlist(y))))
}

#' Set \code{symbolList} of Echarts
#'
#' When an echart object is generated, you can modify it by setting symbolList using
#' \code{\link{\%>\%}}.
#' You can modify \code{symbolList} of the echarts object using this function. The symbolList
#' will be then mapped to data series in order.
#' @param chart \code{echarts} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param symbols A vector assigning symbols. You can use an array of symbols.
#' If the the symbols array is shorter than the levels of the series in length,
#' the last symbol will be used to extend the array. Default NULL.
#' \itemize{
#'  \item If you set symbolList NULL or
#' leave it unset, the function circulates the default symbol list of Echarts:
#' \code{c('circle', 'rectangle', 'triangle', 'diamond', 'emptyCircle', 'emptyRectangle',
#' 'emptyTriangle', 'emptyDiamond')}.\cr
#'  \item You can also assign non-standard symbols,
#' such as \code{'heart', 'droplet', 'pin', 'arrow', 'star3', 'star4', 'star5', 'star6',
#' 'star7', 'star8', 'star9'}, etc.\cr
#'  \item When assigned to \strong{'none', no symbol will be shown}, you can thus yield lines
#' without points on it.  \cr
#'  \item The elements not in the above eligible symbols list will be eliminated.
#' }
#' @param ... Elipsis.
#'
#' @return A modified echarts object.
#' @export
#'
#' @references \url{http://echarts.baidu.com/echarts2/doc/option.html#title~symbolList}
#' @examples
#' \dontrun{
#' g <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, series=Species)
#' g %>% setSymbols('emptycircle')
#' g %>% setSymbols(c('heart', 'pin'))
#' }
setSymbols <- function(chart, symbols=NULL, ...){
    stopifnot(inherits(chart, 'echarts'))
    hasZ <- 'timeline' %in% names(chart$x)
    if (!is.null(symbols)){
        intersectSymbols <- symbols[tolower(symbols) %in% tolower(validSymbols)]
        idx <- sapply(intersectSymbols, function(x) {
            return(which(tolower(validSymbols) == x))
        })
        symbolList <- as.list(validSymbols[unlist(idx)])
        if (length(symbolList) > 0) {
            if (hasZ){
                nlvlseries <- sapply(chart$x$options, function(lst) {
                    length(lst$series)})
                nlvlseries <- max(unlist(nlvlseries))
                if (length(symbolList) < nlvlseries)
                    symbolList <- c(symbolList,
                                    rep(symbolList[length(symbolList)],
                                        nlvlseries-length(symbolList)))
                chart$x$options[[1]][['symbolList']] <- symbolList
            }else{
                nlvlseries <- length(chart$x$series)
                if (length(symbolList) < nlvlseries)
                    symbolList <- c(symbolList,
                                    rep(symbolList[length(symbolList)],
                                        nlvlseries-length(symbolList)))
                chart$x[['symbolList']] <- symbolList
            }
        }
    }
    return(chart %>% reElementId())

}

getSeriesPart <- function(chart, element=c('name', 'type', 'data', 'large'),
                          ...){
    ## get all the element names vector from an echarts object's series
    stopifnot(inherits(chart, 'echarts'))
    element <- match.arg(element)
    hasZ <- 'timeline' %in% names(chart$x)
    if (hasZ){
        obj <- sapply(seq_len(length(chart$x$options)), function(i) {
            sapply(chart$x$options[[i]]$series, function(lst) lst[[element]])
        })
        data <- sapply(seq_len(length(chart$x$options)), function(i) {
            sapply(chart$x$options[[i]]$series, function(lst) lst[['data']])
        })
        if (chart$x$options[[1]]$series[[1]]$type %in%
            c('funnel', 'pie', 'radar')){
            if (element == 'name') obj <- unlist(data)[names(unlist(data))=='name']
            if (element == 'data') obj <- unlist(data)[names(unlist(data))=='value']
        }
    }else{
        obj <- sapply(chart$x$series, function(lst) lst[[element]])
        data <- sapply(chart$x$series, function(lst) lst[['data']])
        if (chart$x$series[[1]]$type %in% c('funnel', 'pie', 'radar')){
            if (element == 'name') obj <- unlist(data)[names(unlist(data))=='name']
            if (element == 'data') obj <- unlist(data)[names(unlist(data))=='value']
        }
    }
    return(unlist(obj))
}



#' Set \code{legend} of Echarts
#'
#' When an echart object is generated, you can modify it by setting legend using
#' \code{\link{\%>\%}}.
#' You can modify the legend of the echarts object using this function.
#' @param chart \code{echarts} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param show Logical. Show the legend or not. Default TRUE.
#' @param pos Clock position of the legend. Default 11. Refer to \code{\link{vecPos}}.
#' Or you can define the position vector \code{c(x, y, orient)} yourself.
#' @param selected A vector of series names that are selected on load. If you assign 'none',
#' then none of the series will be selected in the beginning.
#' @param itemGap The gap between legend items. Default 5px.
#' @param borderColor The border color of the legend. Default '#ccc'.
#' @param borderWidth The border width of the legend. Default 0px (not shown).
#' @param textStyle A list of textStyle definition to decorate the text. E.g.,
#' \code{list(color='#444')} or \code{list(color='auto')}.
#' @param formatter A named formatter template or a string containing javascript codes.
#' E.g., \code{'{name}'}.
#' @param overideData A list of data to overide the legend text. E.g.,
#' \code{list(list(name='Series 1', icon='image://../asset/ico/favicon.png',
#' textStyle=list(color='#bbb')))}
#' @param ... Elipsis.
#'
#' @return A modified echarts object.
#' @export
#'
#' @references \url{http://echarts.baidu.com/echarts2/doc/option.html#title~legend}
#' @examples
#' \donrun{
#' # No timeline
#' g <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, series=Species, type='scatter')
#' g %>% setLegend(selected="versicolor")
#' g %>% setLegend(selected=levels(iris$Species)[1:2],
#'                 textStyle=list(fontFamily='Times New Roman', color='purple',
#'                                fontWeight='bold', fontSize=16))
#'
#' # With Timeline
#' g1 <- iris %>% echartR(x=Sepal.Width, y=Petal.Width, z=Species, type='scatter')
#' g1 %>% setLegend(pos=12, selected='none',
#'                  textStyle=list(fontFamily='Courier New', fontSize=16))
#' }
setLegend <- function(
    chart, show=TRUE, pos=11, selected=NULL, itemGap=5, borderColor='#ccc',
    borderWidth=0, textStyle=list(color='auto'), formatter=NULL, overideData=NULL,
...){
    stopifnot(inherits(chart, 'echarts'))

    hasZ <- 'timeline' %in% names(chart$x)
    series <- getSeriesPart(chart, 'name')
    if (!is.null(dim(series))) series <- series[,1]
    series <- series[series != '']
    # get series name vector from echarts object

    lstLegend <- list(show=show, data=as.list(unique(series)))

    if (is.numeric(pos[[1]]) && pos[[1]] <= 12){
        lstLegend[c('x', 'y', 'orient')] <- vecPos(pos[[1]])
    }else if (length(pos)==3 && tolower(pos[[1]]) %in%
              c('left', 'right', 'center') &&
              tolower(pos[[2]]) %in% c('top', 'center', 'bottom') &&
              tolower(pos[[3]]) %in% c('vertical', 'horizontal')){
        lstLegend[c('x', 'y', 'orient')] <- pos
    }

    if (!is.null(selected)){
        unselected <- series[! series %in% selected]
        lstLegend[['selected']] <- emptyList()
        for (item in unselected){
            lstLegend[['selected']][[item]] <- FALSE
        }
        if (length(selected) != length(series)){
            if (length(selected) == 1) lstLegend[['selectedMode']] <- 'single'
            else lstLegend[['selectedMode']] <- 'multiple'
        }
    }
    if (!missing(itemGap)) if (itemGap != 5)
        lstLegend[['itemGap']] <- itemGap
    if (!missing(borderColor)) if (borderColor != '#ccc')
        lstLegend[['borderColor']] <- borderColor
    if (!missing(borderWidth)) if (borderWidth > 0)
        lstLegend[['borderWidth']] <- borderWidth

    if (is.list(textStyle) && !identical(textStyle, list(color='auto')))
        if (all(names(textStyle) %in% c('fontFamily', 'color', 'fontSize',
                                        'fontStyle', 'fontWeight')))
            lstLegend[['textStyle']] <- textStyle
    if (!missing(formatter)) if (!is.null(formatter) && is.list(formatter))
        lstLegend[['formatter']] <- formatter
    if (!missing(overideData)) if (!is.null(overideData) && is.list(overideData))
        if (all(names(overideData) %in% c('name', 'textStyle', 'icon')))
            lstLegend[['data']] <- overideData

    if (! is.null(show)) {
        if (hasZ){
            chart$x$options[[1]][['legend']] <- lstLegend
        }else{
            chart$x[['legend']] <- lstLegend
        }
    }

    return(chart %>% tuneGrid())
}


autoPolar <- function(chart, type){
    stopifnot(inherits(chart, 'echarts'))
    chartTypes <- getSeriesPart(chart, 'type')
    hasZ <- 'timeline' %in% names(chart$x)
    if (!all(chartTypes %in% c('radar'))) return(chart)

    # get chart meta data
    hasZ <- 'timeline' %in% names(chart$x)
    if (hasZ){
        data <- lapply(chart$x$options, function(l) getMeta(l))
        list.names <- names(data[[1]])
        data <- lapply(list.names, function(v) {
            do.call('rbind', lapply(data, function(l) l[[v]]))
        })
        names(data) <- list.names
    }else data <- getMeta(chart)
    dt <- data.frame(x=data$x[,1], y=data$y[,1])
    dt$idx <- if (is.null(data$series)) 1 else data$series[,1]
    index <- as.character(unique(dt$idx))
    dt$series <- if (ncol(data$x) == 1) names(data$y)[1] else data$x[,2]
    if (!is.null(data$z)) {
        dt$z <- data$z[,1]
        dt <- data.table::dcast(dt, idx + x + series + z ~., sum, value.var='y')
        names(dt) <- c('idx', 'x', 'series', 'z', 'y')
    }else{
        dt <- data.table::dcast(dt, idx + x + series ~., sum, value.var='y')
        names(dt) <- c('idx', 'x', 'series', 'y')
    }

    # layout
    layouts <- autoMultiPolarChartLayout(length(index), gap=1.5)
    rows <- layouts$rows
    cols <- layouts$cols
    centers <- layouts$centers
    rownames(centers) <- index
    radius <- layouts$radius

    # build polar lists
    obj <- lapply(index, function(i){
        dat <- dt[dt$idx == i,]
        o <- list(center=paste0(centers[i, 1:2], '%'), radius=paste0(radius, '%'))
        indicator <- lapply(as.character(unique(dat$x)), function(x){
            list(text=x, max=ifna(max(unname(dt[dt$x==x, 'y'])), 0) * 1.2)
        })
        o[['indicator']] <- indicator
        if (grepl('circle', type[which(index == i), 'misc']))
            o[['type']] <- 'circle'
        return(o)
    })

    if (hasZ){
        chart$x$options[[1]][['polar']] <- obj
    }else{
        chart$x[['polar']] <- obj
    }

    return(chart %>% reElementId())
    # if (type[1] %in% c('radar')){
    #     x <- factor(x,levels=unique(x))
    #     indicator <- levels(x)
    #     lstPolar <- list(list(radius='70%', indicator=list()))
    #     for (i in 1:length(indicator)){
    #         lstPolar[[1]][['indicator']][[i]] <- list(
    #             text = as.character(indicator[i]),
    #             max = max(data[data[,xvar]==indicator[i],yvar]) * 1.25
    #         )
    #     }
    # }
}

#' Set \code{polar} of Echarts (For Radar Charts)
#'
#' Set the \code{polar} coordinates of Echarts for radar charts.  \cr
#' When an echart object is generated, you can modify it by setting aesthetics using
#' \code{\link{\%>\%}}.
#'
#' @param chart \code{echarts} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param polarIndex Integer vector. The index of the polar systems you want to set. Default NULL.
#' @param center Vector of the x, y position of the polar center. Could be numeric or character
#' (percent form) vectors of length 2. Default c('50\%', '50\%').
#' @param radius The radius of the polar system, could be numeric or character (percent form).
#' Default '75\%'.
#' @param startAngle Numeric (-180 ~ 180). The start angle. Default 90.
#' @param splitNumber Numeric. The number of sections to divide. Default 5.
#' @param boundaryGap Numeric vector of length 2. The gapping policy of the axis. Default c(0, 0).
#' @param scale Logical. Whether to ignore zero and zoom toward the range of _min and _max.
#' @param axisLine List. Axis line styles. You can set its \code{show, onZero, lineStyle}
#' features. Default \code{list(show=TRUE)}.
#' @param axisLabel List. Axis label styles. You can set its \code{show, rotate, margin,
#' clickable, formatter, textStyle} features. Default \code{list(show=FALSE)}.
#' @param splitLine List. Split line styles. You can set its \code{show, lineStyle}
#' features. Default \code{list(show=TRUE)}.
#' @param splitArea List. Split area styles. You can set its \code{show, onGap, areaStyle}
#' features. Default \code{list(show=TRUE)}.
#' @param type Character, 'polygon' or 'circle'. The type of the polar shape.
#' Default 'polygon'.
#' @param indicator List. The radar indicator and labels. The basic structure is \code{
#' list(list(text='...', min=..., max=..., axisLabel=list(...)), list(text='...', min=..., max=...),
#' list(...), ...)}. Default is empty.
#' @param axisName List. The name of the axis. You can set its \code{show, formatter,
#' textStyle} features. Default \code{list(show=TRUE, formatter=NULL, textStyle=list(color='#333'))}.
#' @param ... Elipsis
#'
#' @return A modified echarts object
#' @export
#'
#' @examples
#' \dontrun{
#' cars <- mtcars[c('Merc 450SE','Merc 450SL','Merc 450SLC'),
#'               c('mpg','disp','hp','qsec','wt','drat')]
#' cars$model <- rownames(cars)
#' cars <- data.table::melt(cars, id.vars='model')
#' names(cars) <- c('model', 'indicator', 'Parameter')
#' g <- echartr(cars, indicator, Parameter, model, type='radar') %>%
#'          setTitle('Merc 450SE  vs  450SL  vs  450SLC')
#' g %>% setPolar(c(1,3), type='circle') %>%
#'       setPolar(2, splitArea=list(show=FALSE)) %>%
#'       setPolar(3, axisName=list(textStyle=list(color='red')))
#' }
#'
setPolar <- function(chart, polarIndex=NULL, center=c('50%', '50%'), radius='75%',
                     startAngle=90, splitNumber=5, boundaryGap=c(0, 0),
                     scale=FALSE, axisLine=NULL, axisLabel=NULL, splitLine=NULL,
                     splitArea=NULL, type=c('polygon', 'circle'),
                     indicator=NULL, axisName=NULL,
...){

    stopifnot(inherits(chart, 'echarts'))
    chartTypes <- getSeriesPart(chart, 'type')
    if (!all(chartTypes=='radar')) return(chart)

    hasZ <- 'timeline' %in% names(chart$x)
    if (hasZ){
        nIndex <- length(chart$x$options[[1]]$series)
    }else{
        nIndex <- length(chart$x$series)
    }

    if (is.null(polarIndex)) polarIndex <- 1:nIndex else
        if (!all(data.table::between(polarIndex, 1, nIndex)))
            stop(paste('polarIndex is not valid. It should all be between 1 and', nIndex))

    lstPolar <- list()
    if (!missing(center)) if (!identical(ifnull(center, c('50%', '50%')), c('50%', '50%')))
        lstPolar[['center']] <- center
    if (!missing(radius)) if (!identical(ifnull(radius, '75%'), '75%'))
        lstPolar[['radius']] <- radius
    if (!missing(startAngle)) if (ifnull(startAngle, 90) != 90)
        lstPolar[['startAngle']] <- startAngle
    if (!missing(splitNumber)) if (ifnull(splitNumber, 5) != 5)
        lstPolar[['splitNumber']] <- splitNumber
    if (!missing(boundaryGap)) if (! identical(ifnull(boundaryGap, c(0,0)), c(0,0)))
        lstPolar[['boundaryGap']] <- boundaryGap
    if (!missing(scale)) if (ifnull(scale, FALSE))
        lstPolar[['scale']] <- scale
    if (!missing(axisLine)) if (!is.null(axisLine))
        lstPolar[['axisLine']] <- axisLine
    if (!missing(axisLabel)) if (!is.null(axisLabel))
        lstPolar[['axisLabel']] <- axisLabel
    if (!missing(splitLine)) if (!is.null(splitLine))
        lstPolar[['splitLine']] <- splitLine
    if (!missing(splitArea)) if (!is.null(splitArea))
        lstPolar[['splitArea']] <- splitArea
    type <- match.arg(type)
    if (type != 'polygon') lstPolar[['type']] <- type
    if (!missing(indicator)) if (!is.null(indicator))
        lstPolar[['indicator']] <- indicator
    if (!missing(axisName)) if (!is.null(axisName))
        lstPolar[['name']] <- axisName

    for (i in polarIndex){
        if (hasZ){
            chart$x$options[[1]]$polar[[i]] <- mergeList(
                chart$x$options[[1]]$polar[[i]], lstPolar)
        }else{
            chart$x$polar[[i]] <- mergeList(
                chart$x$polar[[i]], lstPolar)
        }
    }

    return(chart %>% reElementId())
}


#' Set Theme Or Misc Aesthetics (color, background, animation, border effects) of Echarts
#'
#' Set the entire theme of Echarts. You can use a pre-installed theme or define you own themes. \cr \cr
#' You can also set aesthetics of Echarts separately, including \code{color, bgColor, animation, calculable,
#' borderColor, borderWidth}.\cr \cr
#' When an echart object is generated, you can modify it by setting aesthetics using
#' \code{\link{\%>\%}}.
#'
#' @section Self-defined Themes (UDT):
#' You can design your prefered themes using \url{http://echarts.baidu.com/echarts2/doc/example/themeDesigner.html}.\cr
#' \cr The UDTs in \code{echarts} are JS objects. You can write it in a list form and \code{setTheme}
#' will parse it into JSON string for process. \cr \cr
#' A typical theme JS looks like: \cr
#' \code{{\cr
#'  color: ['#ff7f50','#87cefa','#da70d6','#32cd32','#6495ed'], \cr
#'  title: {x: 'left', y: 'top'}, \cr
#'  legend: {orient: 'horizontal'} \cr
#' }} \cr \cr
#' You should write in the format below: \cr
#' \code{list(color=c('#ff7f50','#87cefa','#da70d6','#32cd32','#6495ed'), \cr
#'  title=list(x='left', y='top'), legend=list(orient='horizontal'))}
#'
#' @param chart \code{echarts} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param theme \describe{
#' \item{Pre-installed themes}{\code{'default', 'macarons', 'infographic', 'blue', 'dark', 'gray',
#' 'green', 'helianthus', 'macarons2', 'mint', 'red', 'roma', 'sakura', 'shine', 'vintage'}}
#' \item{User-defined themes}{E.g., \code{list(color=c('#ff7f50','#87cefa','#da70d6','#32cd32','#6495ed'), \cr
#' title=list(x='left', y='top'), legend=list(orient='horizontal'))}}
#' }
#' @param palette name of the palette or a color vector. Default NULL to get echarts default.
#' It could be:
#' \describe{
#'  \item{\code{asis}}{keep the color palette applied in current echarts object}
#'  \item{\link{RColorBrewer} palettes}{Including 'BrBG', 'PiYG', 'PRGn', 'PuOr', 'RdBu',
#'  'RdGy', 'RdYlBu', 'RdYlGn', 'Spectral', 'Accent', 'Dark2', 'Paired', 'Pastel1',
#'  'Pastel2', 'Set1', 'Set2', 'Set3', 'Blues', 'BuGn', 'BuPu', 'GnBu', 'Greens',
#'  'Greys', 'Oranges', 'OrRd', 'PuBu', 'PuBuGn', 'PuRd', 'Purples', 'RdPu', 'Reds',
#'  'YlGn', 'YlGnBu', 'YlOrBr', 'YlOrRd'}
#'  \item{\link{ggthemes} palettes}{'calc', 'economist', 'economist_white', 'economist_stata',
#'  'excel', 'exel_fill', 'excel_line', 'excel_new', 'few', 'fivethirtyeight', '538', 'manyeyes',
#'  'gdocs', 'pander', 'tableau', 'stata', 'stata1','stata1r','statamono', 'ptol',
#'  'tableau20', 'tableau10medium', 'tableaugray', 'tableauprgy', 'tableaublrd',
#'  'tableaugnor', 'tableaucyclic', 'tableau10light', 'tableaublrd12', 'tableauprgy12',
#'  'tableaugnor12','hc','darkunica', 'solarized','solarized_red', 'solarized_yellow',
#'  'solarized_orange','solarized_magenta','solarized_violet', 'solarized_blue',
#'  'solarized_cyan', 'solarized_green', 'wsj', 'wsj_rgby', 'wsj_red_green',
#'  'wsj_black_green', 'wsj_dem_rep', 'colorblind', 'trafficlight'}
#'  \item{Aetna official palettes}{Including 'aetnagreen', 'aetnablue', 'aetnaviolet',
#'  'aetnaorange', 'aetnateal', 'aetnacranberry'}
#'  \item{Other palettes}{'rainbow', 'terrain', 'topo', 'heat', 'cm'}
#' }
#' \strong{Usage:} \cr
#' \itemize{
#'  \item If the value is not set, and the function defaults will be loaded \cr
#'  \item Set palette=NULL to use Echarts defaults \cr
#'  \item Set palette=palette name to assign any palette listed above \cr
#'  \item Set palette=\code{palette name(number)} to restrict number of colors within the
#'  palette (e.g., \code{palette='calc(3)'} picks 3 colors out of 'calc' \strong{RANDOMLY}) \cr
#'  \item Set palette=\code{c(color1, color2, color3, ...)} to define a palette vector,
#'  made of which either color names or Hex expressions. Use \code{\link{colors}()} to check
#'  available color names and check the effects using \code{demo(colors)}.
#' }
#' @param bgColor Color name/value of the background. Default is transparent
#' (\code{'rgba(0,0,0,0)'})
#' @param renderAsImage Logical. If FALSE, the interactive effects are disabled. Default TRUE.
#' @param calculable Logical. If TRUE, the chart is re-calculated after drag. Default FALSE.
#' @param calculableColor The border color of the tooltip during \code{calculable} effect.
#' Default 'rgba(255,165,0,0.6)'.
#' @param calculableHolderColor The color of \code{calculableHolder}. Default '#ccc'.
#' @param animation Logical. If TRUE, the animation is on at initiation. Default TRUE.
#' For IE8, it is recommended to set FALSE.
#' @param animationEasing The slight moving effect of major elements. Default 'ExponentialOut'.
#' Other choices: 'Linear', 'QuadraticIn', 'QuadraticOut', 'QuadraticInOut', 'CubicIn',
#' 'CubicOut', 'CubicInOut', 'QuarticIn', 'QuarticOut', 'QuarticInOut', 'QuinticIn',
#' 'QuinticOut', 'QuinticInOut', 'SinusoidalIn', 'SinusoidalOut', 'SinusoidalInOut',
#' 'ExponentialIn', 'ExponentialInOut', 'CircularIn', 'CircularOut', 'CircularInOut',
#' 'ElasticIn', 'ElasticOut', 'ElasticInOut', 'BackIn', 'BackOut', 'BackInOut',
#' 'BounceIn', 'BounceOut', 'BounceInOut'
#' @param animationDuration The duration into animation. Default 2000 (ms).
#' @param width Width (px) of the whole chart.
#' @param height Height (px) of the whole chart.
#' @param ... Elipsis
#'
#' @return A modified echarts object
#' @importFrom jsonlite toJSON
#' @export
#'
#' @seealso \code{\link{brewer.pal}}, \code{\link{colors}}
#' @references
#' \code{theme} \cr
#' \url{http://echarts.baidu.com/echarts2/doc/example/theme.html} \cr \cr
#' \code{backgroundColor} \cr
#' \url{http://echarts.baidu.com/echarts2/doc/option.html#title~backgroundColor} \cr \cr
#' \code{colors} \cr
#' \url{http://echarts.baidu.com/echarts2/doc/option.html#title~color} \cr
#' \url{http://colorbrewer2.org} \cr \cr
#' \code{other features} \cr
#' \url{http://echarts.baidu.com/echarts2/doc/option.html#title~renderAsImage} \cr
#' \url{http://echarts.baidu.com/echarts2/doc/option.html#title~calculable} \cr
#' \url{http://echarts.baidu.com/echarts2/doc/option.html#title~animation} \cr
#' \url{http://echarts.baidu.com/echarts2/doc/option.html#title~calculableColor} \cr
#' \url{http://echarts.baidu.com/echarts2/doc/option.html#title~calculableHolderColor}
#' @examples
#' \dontrun{
#' g <- echartR(iris, Sepal.Width, Petal.Width, series=Species)
#'
#' # Set themes
#' ## pre-installed themes
#' g %>% setTheme("infographic")
#' g %>% setTheme("blue")
#' g %>% setTheme("dark")
#' g %>% setTheme("gray")
#' g %>% setTheme("green")
#' g %>% setTheme("helianthus")
#' g %>% setTheme("macarons2")
#' g %>% setTheme("mint")
#' g %>% setTheme("red")
#' g %>% setTheme("sakura")
#' g %>% setTheme("shine")
#' g %>% setTheme("vintage")
#'
#' ## self-defined themes
#' theme <- list(color=c("#7AC143", "#7D3F98", "#F47721", "#D20962", "#00A78E",
#'               "#00BCE4", "#B8D936", "#EE3D94"), backgroundColor="#fef8ef")
#' g %>% setTheme(theme)
#'
#' ## Misc aethetics
#' g <- echartR(iris, x=Sepal.Width, y=Petal.Width, series=Species, type='scatter')
#' g %>% setTheme(palette='hc')
#' g %>% setTheme(palette=c('red', 'gold', 'deepskyblue'), 'gray95',
#'         animationHoldColor='red', animationEasing='CircularOut',
#'         animationDuration=10000)
#' }
setTheme <- function(
    chart, theme=c(
        'asis', 'default', 'macarons', 'infographic', 'blue', 'dark', 'gray', 'green',
        'helianthus', 'macarons2', 'mint', 'red', 'roma', 'sakura', 'shine', 'vintage'),
    palette='asis', bgColor=NULL, renderAsImage=FALSE, calculable=FALSE,
    calculableColor=NULL, calculableHolderColor=NULL, animation=TRUE,
    animationEasing=NULL, animationDuration=NULL, width=NULL, height=NULL,
    ...){
    stopifnot(inherits(chart, 'echarts'))

    ## pass theme in
    if (is.list(theme)){
        theme <- toJSON(theme)
    }else{
        theme <- match.arg(theme)
    }
    if (!identical(theme, 'asis')) chart$x[['theme']] <- theme
    if (missing(theme) || is.null(theme)) chart$x[['theme']] <- NULL

    hasZ <- 'timeline' %in% names(chart$x)
    ## set colors
    if (hasZ){
        nSeries <- sapply(chart$x$options, function(lst) {
            return(length(lst$series))
        })
        nSeries <- max(unlist(nSeries))
        if (!missing(palette)) if (!identical(palette, 'asis')) {
            lstColor <- as.list(getColors(palette, n=nSeries))
            chart$x$options[[1]][['color']] <- lstColor[1:nSeries]
        }
        lst <- chart$x$options[[1]]
    }else{
        nSeries <- length(getSeriesPart(chart, 'name'))
        if (nSeries == 0) nSeries <- 1
        if (!missing(palette)) if (!identical(palette, 'asis')) {
            lstColor <- as.list(getColors(palette, n=nSeries))
            chart$x[['color']] <- lstColor[1:nSeries]
        }
        lst <- chart$x
    }

    ## set the rest elements
    if (!missing(bgColor)) if (! is.null(bgColor) && bgColor != 'rgba(0,0,0,0)'){
        lst[['backgroundColor']] <- ifelse(
            grepl("^rgba\\(", bgColor), bgColor, getColors(bgColor))
        if (grepl("^rgba\\(", bgColor)){
            backColor <- as.numeric(unlist(strsplit(bgColor,
                                                    "[\\(,\\)]"))[2:5])
            contrastColor <- c(rep(255, 4) - backColor)
            contrastColor <- paste0('rgba(', paste(contrastColor, collapse=","),
                                    ')')
        }else if (grepl("^#", bgColor)){
            cColor <- c(rep(255, 4) - col2rgb(bgColor, TRUE))
            contrastColor <- rgb(cColor[1], cColor[2], cColor[3], max=255)
        }
    }
    if (!missing(renderAsImage)) if (renderAsImage)
        lst[['renderAsImage']] <- renderAsImage
    if (!missing(calculable)) if (calculable) lst[['calculable']] <- calculable
    if (!missing(calculableColor))
        if (!is.null(calculableColor) && calculableColor != 'rgba(255,165,0,0.6)')
            lst[['calculableColor']] <- ifelse(
                grepl("^rgba\\(", calculableColor), calculableColor,
                getColors(calculableColor))
    if (!missing(calculableHolderColor))
        if (!is.null(calculableHolderColor) && calculableHolderColor != '#ccc')
            lst[['calculableHolderColor']] <- ifelse(
                grepl("^rgba\\(", calculableHolderColor), calculableHolderColor,
                getColors(calculableHolderColor))
    if (!missing(animation)) if (!animation) lst[['animation']] <- FALSE
    if (!missing(animationEasing))
        if (!is.null(animationEasing) && animationEasing != 'ExponentialOut'){
            if (animationEasing %in%
                c('Linear', 'QuadraticIn', 'QuadraticOut', 'QuadraticInOut',
                  'CubicIn', 'CubicOut', 'CubicInOut', 'QuarticIn', 'QuarticOut',
                  'QuarticInOut', 'QuinticIn', 'QuinticOut', 'QuinticInOut',
                  'SinusoidalIn', 'SinusoidalOut', 'SinusoidalInOut', 'ExponentialIn',
                  'ExponentialInOut', 'CircularIn', 'CircularOut', 'CircularInOut',
                  'ElasticIn', 'ElasticOut', 'ElasticInOut', 'BackIn', 'BackOut',
                  'BackInOut', 'BounceIn', 'BounceOut', 'BounceInOut'))
                lst[['animationEasing']] <- animationEasing
        }
    if (!missing(animationDuration))
        if (!is.null(animationDuration) && animationDuration != 2000){
            lst[['animationDuration']] <- animationDuration
            if (hasZ) chart$x$timeline[['playInterval']] <- animationDuration
        }

    ## merge list back to echarts object
    if (hasZ) chart$x$options[[1]] <- lst
    else chart$x <- lst

    ## width and height
    if (!is.null(width)) chart[['width']] <- width
    if (!is.null(height)) chart[['height']] <- height

    return(chart %>% tuneGrid())
}

makeTooltip <- function(type, trigger=NULL, formatter=NULL,
                        islandFormatter='{a} < br/>{b} : {c}',
                        position=NULL, enterable=FALSE, axisPointer=NULL,
                        textStyle=NULL, showDelay=20, hideDelay=100,
                        transitionDuration=0.4, bgColor='rgba(0,0,0,0.7)',
                        borderColor='#333', borderWidth=0, borderRadius=4,
                        show=TRUE, keepDefault=FALSE, ...){
    if (!ifnull(show, TRUE)) {
        lstTooltip = list(show=FALSE)
    }else{
        if (is.null(trigger)){
            trigger <- ifelse(
                type %in% c('pie', 'ring', 'funnel', 'pyramid', 'map', 'rose',
                            'wordcloud', 'radar', 'chord', 'force', 'gauge'),
                'item', 'axis')
        }else{
            trigger <- match.arg(trigger, c('item', 'axis'))
        }

        lstTooltip <- list(show = ifnull(show, TRUE), trigger = trigger)

        ## fetch default features
        lstTooltip[c('axisPointer', 'textStyle')] <-
            list(list(
                type=ifelse(type %in% c('bar', 'histogram', 'line'), 'line',
                            ifelse(type %in% c('scatter', 'point', 'bubble')
                                   , 'cross', 'none')),
                crossStyle=list(type='dashed'), lineStyle='solid'
            ),
            list(color='#fff')
            )
        if (keepDefault){
            lstTooltip[c('islandFormatter', 'enterable', 'showDelay', 'hideDelay',
                         'transitionDuration', 'backgroundColor', 'borderWidth')] <-
                list('{a} < br/>{b} : {c}', FALSE, 20, 100, 0.4, '#333', 0)
        }
        ## fetch features
        if (!is.null(position)) lstTooltip[['position']] <- position
        if (!is.null(formatter)) lstTooltip[['formatter']] <- formatter
        if (ifnull(islandFormatter, '{a} < br/>{b} : {c}') != '{a} < br/>{b} : {c}')
            lstTooltip[['islandFormatter']] <- islandFormatter
        if (ifnull(enterable, FALSE)) lstTooltip[['enterable']] <- enterable
        if (!is.null(axisPointer)) {
            if (all(names(axisPointer) %in% c('type', 'lineStyle', 'crossStyle',
                                              'shadowStyle', 'textStyle')))
                lstTooltip[['axisPointer']] <- axisPointer
            else warning(paste(
                "axisPointer must be a list containing any of the below:\n",
                "'type', 'lineStyle', 'crossStyle','shadowStyle', 'textStyle'."))
        }

        if (!is.null(textStyle)) {
            if (all(names(textStyle) %in% c('color', 'decoration', 'align',
                                            'baseline', 'fontFamily', 'fontSize',
                                            'fontStyle', 'fontWeight')))
                lstTooltip[['textStyle']] <- textStyle
            else warning(paste(
                "textStyle must be a list containing any of the below:\n",
                "'color', 'decoration', 'align', 'baseline', 'fontFamily',",
                "'fontSize','fontStyle', 'fontWeight'."))
        }
        if (ifnull(showDelay, 20) != 20) lstTooltip[['showDelay']] <- showDelay
        if (ifnull(hideDelay, 20) != 100) lstTooltip[['hideDelay']] <- hideDelay
        if (ifnull(transitionDuration, 0.4) != 0.4)
            lstTooltip[['transitionDuration']] <- transitionDuration
        if (ifnull(bgColor, 'rgba(0,0,0,0.70)') != 'rgba(0,0,0,0.70)')
            lstTooltip[['backgroundColor']] <- getColors(bgColor)[1]
        if (ifnull(borderColor, '#333') != '#333')
            lstTooltip[['borderColor']] <- getColors(borderColor)[1]
        if (ifnull(borderWidth, 0) > 0) lstTooltip[['borderWidth']] <- borderWidth
        if (ifnull(borderRadius, 4) != 4)
            lstTooltip[['borderRadius']] <- borderRadius
    }
    return(lstTooltip)
}

determineFormatter <- function(type){
    if (type %in% c('scatter', 'bubble', 'point')){
        formatter <- tooltipJS('scatter')
    }else if (type %in% c('ring','pie')){
        formatter <- tooltipJS('pie')
    }else if (type %in% c('chord', 'force')){
        if (length(getSeriesPart(chart, 'name')) == 1){
            formatter <- tooltipJS('chord_mono')
        }else{
            formatter <- tooltipJS('chord_multi')
        }
    }else if (type == 'k'){
        formatter <- tooltipJS('k')
    }else if (type == 'histogram'){
        formatter <- tooltipJS('hist')
    }else{
        formatter <- NULL
    }
    return(formatter)
}

#' Set \code{tooltip} of Echarts
#'
#' Set tooltip of Echarts, at various levels (entire chart, specific series) with
#' various formats. \cr
#' When an echart object is generated, you can modify it by setting tooltip using
#' \code{\link{\%>\%}}.
#' @note Note that the \code{tooltip} feature is inheritable in terms of timeline.
#' \code{setTooltip} automatically breaks the inheritability by resetting tooltip
#' formats in the timeslots following the timeslots whose tooltip format are changed.
#' .
#' @param chart \code{echarts} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param series A vector of series indices or names. e.g., \code{c('setosa', 'virginica')}
#' or \code{1:2}
#' @param timeslots A vector of time slices indices or names, e.g., \code{c(1990, 1992)}
#'  or \code{c(1,3)}. You can also use \code{z} as a short form of \code{timeslots}.
#' @param trigger Type of trigger, \code{'item'} or \code{'axis'}.
#' @param formatter The format of the tooltip content.
#' \describe{
#'  \item{string(template)}{
#'   \itemize{
#'   \item \{a\} | \{a0\}
#'   \item \{b\} | \{b0\}
#'   \item \{c\} | \{c0\}
#'   \item \{d\} | \{d0\} (not applicable for some types)
#'   \item \{e\} | \{e0\} (not applicable for some types)
#'   }}
#'  \item{function}{the js list is in the form \code{[params, ticket, callback]}.}
#' }
#' @param islandFormatter Formatter of data island for calcualable effect. Can be
#' string (default \code{'{a} < br/>{b} : {c}'}) or JS function.
#' @param position Can be fixed position array \code{c(x, y)} or a JS function, e.g.,
#' \code{JS('function([x, y]) {return [newX,newY]}')}. Default NULL.
#' @param enterable If users can click into the tooltip for interacions. Default FALSE.
#' @param axisPointer The pointer formatter of axis. Default is a list \code{
#' list(type = "line", \cr
#'      lineStyle = list(color = "#48b", width = 2, type = "solid"), \cr
#'      crossStyle = list(color = "#1e90ff", width = 1, type = "dashed"), \cr
#'      shadowStyle = list(color = "rgba(150,150,150,0.3)", width = "auto", type = "default") \cr
#' )}.
#' @param textStyle text style of the tooltip. In a list form. Default \code{list(color
#' ="#fff")}. The list coud contain elements of \code{color, decoration, fontSize,
#' fontFamily, fontStyle, fontWeight, align, baseline}.
#' @param showDelay Delayed time at show (ms). Default 20ms.
#' @param hideDelay Delayed time at hide (ms). Default 100ms.
#' @param transitionDuration The time spent at animation exchange. Default 0.4. Set
#' if 0 if you want real-time interaction.
#' @param bgColor Background color of tooltips. Default 'rgba(0,0,0,0.7)' (
#' semi-transparent dark gray).
#' @param borderColor Borderline color of the tooltips. Default '#333'.
#' @param borderWidth Border width of the tooltips. Default 0 (not shown).
#' @param borderRadius Border radius of the tooltips. Default 4px.
#' @param show Logical. If the tooltips are shown. Default TRUE.
#' @param ... Elipsis
#'
#' @return A modified echarts object
#' @export
#'
#' @references \url{http://echarts.baidu.com/echarts2/doc/option.html#title~tooltip}
#' @examples
#' \dontrun{
#' g <- echartR(iris, Sepal.Width, Petal.Width, series=Species)
#'
#' ## global tooltip
#' g %>% setTooltip(trigger='item', bgColor='rgba(0,0,200,0.7)')
#'
#' ## series-specific tooltip
#' bg <- sapply(c('orange', 'deepskyblue', 'violet'), col2rgb)
#' bg <- rbind(bg, 0.7)  # extend the color matrix with alpha 0.7
#' bgCol <- unname(apply(bg, 2, rgba))  # get rgba colors with alpha
#' g %>% setTooltip(series='setosa', bgColor=bgCol[1]) %>%
#'       setTooltip(series=2, bgColor=bgCol[2]) %>%
#'       setTooltip(series=3, bgColor=bgCol[3])
#'
#' ## series-and-timeline-specific tooltip
#' bg <- sapply(c('orange', 'deepskyblue', 'violet'), col2rgb)
#' bg <- rbind(bg, 0.7)  # extend the color matrix with alpha 0.7
#' bgCol <- unname(apply(bg, 2, rgba))  # get rgba colors with alpha
#' iris$tag <- 1 + as.integer(row.names(iris)) %% 3
#' iris <- iris[order(iris$tag),]
#' g1 <- echartR(iris, Sepal.Width, Petal.Width, series=Species, z=tag)
#' g1 %>% setTooltip(series='setosa', bgColor=bgCol[1]) %>%
#'        setTooltip(series=2, bgColor=bgCol[2]) %>%
#'        setTooltip(series=3, bgColor=bgCol[3]) %>%
#'        setTooltip(z=1, borderColor='red', borderWidth=3) %>%
#'        setTooltip(z=2, borderColor='gold', borderWidth=3) %>%
#'        setTooltip(z=3, borderColor='green', borderWidth=3)
#'
#' g1 %>% setTooltip(series=2, z=2, bgColor='blue')
#'        # tooltip format of series 2 in the 2nd timeslot is changed to bg blue,
#'        # while it in the 3rd timeslot is reset to default
#' }
setTooltip <- function(chart, series=NULL, timeslots=NULL, trigger=NULL,
                       formatter=NULL, islandFormatter='{a} < br/>{b} : {c}',
                       position=NULL, enterable=FALSE, axisPointer=NULL, textStyle=NULL,
                       showDelay=20, hideDelay=100, transitionDuration=0.4,
                       bgColor='rgba(0,0,0,0.7)', borderColor='#333',
                       borderWidth=0, borderRadius=4, show=TRUE,
                       ...){
    stopifnot(inherits(chart, 'echarts'))
    if ('z' %in% names(list(...))) timeslots <- list(...)[['z']]

    chartTypes <- getSeriesPart(chart, 'type')
    if (is.null(dim(chartTypes))) chartTypes <- as.matrix(chartTypes, ncol=1)
    uniSeries <- getSeriesPart(chart, 'name')
    if (!is.null(dim(uniSeries))) uniSeries <- uniSeries[,1]

    hasZ <- 'timeline' %in% names(chart$x)
    if (! hasZ) {
        timeslots <- NULL
    }else{
        timeslotsIndex <- seq_len(length(chart$x$timeline$data))
        if (!is.null(timeslots)){
            if (all(is.numeric(timeslots))){
                vecZ <- timeslots[timeslots %in% timeslotsIndex]
            }else{
                vecZ <- which(timeslotsIndex %in% timeslots)
            }
            # if (identical(sort(vecZ), seq_len(length(chart$x$timelin$data))))
            #     vecZ <- timeslots <- NULL
        }
    }
    if (length(chartTypes) == 1) {
        series <- NULL
    }else{
        seriesIndex <- seq_len(length(uniSeries))
        if (!is.null(series)){
            if (all(is.numeric(series))){
                vecS <- series[series %in% seriesIndex]
            }else{
                vecS <- which(uniSeries %in% series)
            }
            # if (identical(sort(vecS), seq_len(length(uniSeries))))
            #     vecS <- series <- NULL
        }
    }

    setAlongSZ <- c(!is.null(series), !is.null(timeslots))
    ## By default, do not set tooltip along series or z
    if (ifnull(show, TRUE)){
        if (hasZ){
            if (is.null(chart$x$options[[1]][['tooltip']]))
                chart$x$options[[1]][['tooltip']] <- list(show=TRUE)
            else
                chart$x$options[[1]][['tooltip']][['show']]=TRUE
        }else{
            if (is.null(chart$x[[1]][['tooltip']]))
                chart$x[['tooltip']] <- list(show=TRUE)
            else
                chart$x[['tooltip']][['show']]=TRUE
        }
    }

    fixedPart <- "makeTooltip(
    trigger=trigger, islandFormatter=islandFormatter, position=position,
    enterable=enterable, axisPointer=axisPointer, textStyle=textStyle,
    showDelay=showDelay, hideDelay=hideDelay,
    transitionDuration=transitionDuration,
    bgColor=bgColor, borderColor=borderColor,
    borderWidth=borderWidth, borderRadius=borderRadius,
    show=show, formatter=ifnull(formatter, determineFormatter('"

    defaultPart <- "makeTooltip(keepDefault=TRUE, type='"

    if (identical(setAlongSZ, c(FALSE, FALSE))){  # global set
        lhs <- ifelse(hasZ, "chart$x$options[[1]][['tooltip']]",
                      "chart$x[['tooltip']]")
        rhs <- paste0(fixedPart, chartTypes[[1]], "')), type='",
                      chartTypes[[1]], "')")

    }else if (identical(setAlongSZ, c(TRUE, FALSE))){  # set along series
        if (hasZ) lhs <- paste0("chart$x$options[[1]]$series[[",
                                vecS, "]][['tooltip']]")
        else lhs <- paste0("chart$x$series[[", vecS, "]][['tooltip']]")
        rhs <- paste0(fixedPart, chartTypes[vecS, 1], "')), type='",
                      chartTypes[vecS, 1], "')")

    }else if (identical(setAlongSZ, c(FALSE, TRUE))){  # set along timeline
        if (hasZ) {  # if not hasZ, this senario fails
            lhs <- paste0("chart$x$options[[", vecZ, "]][['tooltip']]")
            rhs <- paste0(fixedPart, chartTypes[1, vecZ], "')), type='",
                          chartTypes[1, vecZ], "')")
            # the following item to vecZ be reset to default
            vecZ1 <- vecZ + 1
            if (any(vecZ1 > length(chart$x$timeline$data))){
                vecZ1[length(vecZ1)] <- min(timeslotsIndex[!timeslotsIndex %in%
                                                               c(vecZ, vecZ1)])
            }
            lhs1 <- paste0("chart$x$options[[", vecZ1, "]][['tooltip']]")
            rhs1 <- paste0(defaultPart, chartTypes[1, vecZ1], "')")
            lhs <- c(lhs, lhs1)
            rhs <- c(rhs, rhs1)
        }

    }else{  # set along s and z
        vecZS <- as.matrix(expand.grid(vecZ, vecS))
        vecZ1 <- vecZ + 1
        if (any(vecZ1 > length(chart$x$timeline$data))){
            vecZ1[length(vecZ1)] <- min(timeslotsIndex[!timeslotsIndex %in%
                                                           c(vecZ, vecZ1)])
        }
        vecZS1 <- as.matrix(expand.grid(vecZ1, vecS))
        if (hasZ) {
            lhs <- paste0("chart$x$options[[", vecZS[,1], "]]$series[[",
                          vecZS[,2], "]][['tooltip']]")
            lhs1 <- paste0("chart$x$options[[", vecZS1[,1], "]]$series[[",
                           vecZS1[,2], "]][['tooltip']]")
        }else{
            lhs <- paste0("chart$x[[", vecZS[,1], "]]$series[[", vecZS[,2],
                          "]][['tooltip']]")
            lhs1 <- paste0("chart$x[[", vecZS1[,1], "]]$series[[", vecZS1[,2],
                           "]][['tooltip']]")
        }

        rhs <- paste0(fixedPart, chartTypes[vecZS], "')), type='",
                      chartTypes[vecZS], "')")
        rhs1 <- paste0(defaultPart, chartTypes[vecZS1], "')")

        lhs <- c(lhs, lhs1)
        rhs <- c(rhs, rhs1)
    }

    eval(parse(text=paste(lhs, "<-", rhs)))

    return(chart %>% reElementId())
}


#' Set \code{timeline} of Echarts
#'
#' Set timeline of Echarts when the echarts object contains timeline slices (z). \cr
#' When an echart object is generated, you can modify it by setting tooltip using
#' \code{\link{\%>\%}}.
#'
#' @param chart \code{echarts} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' @param show Logical. If or not the timeline is shown. Default TRUE.
#' @param type 'time' or 'number' format of the timeline. Default 'time'.
#' @param realtime Logical. If or not the changes take effect in realtime manner.
#' Default TRUE.
#' @param x x coordinate of the upper left point of the timeline bar. Default 80.
#' @param y y coordinate of the upper left point of the timeline bar. Default NULL
#' (automatic).
#' @param x2 x coordinate of the upper left point of the timeline bar. Default 80.
#' @param y2 y coordinate of the upper left point of the timeline bar. Default 0.
#' @param width Width of the timeline. Could be a number or a character in percent
#' form. Default NULL.
#' @param height Height of the timeline. Default 50 (px).
#' @param bgColor Background color of the timeline. Default "rgba(0,0,0,0)" (transparent).
#' @param borderColor Border color of the timeline. Default "#ccc".
#' @param borderWidth Border width of the timeline. Default 0 (px) (not shown).
#' @param controlPosition Position of the control of the timeline. Could be 'left',
#' 'right' or 'none'. Default 'left'.
#' @param autoPlay Logical. If or not the timeline auto displays. Default FALSE.
#' @param loop Logical. If or not the timeline displays in loop mode. Default TRUE.
#' @param playInterval Interval when displays each timeslice. Default 2000 (ms).
#' @param lineStyle A list. Line style of the timeline. Default value: \cr
#' \code{list(color="#666", width=1, type="dashed")}. \cr Supports features of \code{'color',
#' 'width', 'type', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'}
#' @param label A list. Label style of the timeline. Default value: \cr
#' \code{list(show=TRUE, interval="auto", rotate=0, formatter=NULL, \cr
#' textStyle=list(color="#333"))}. \cr Supports features of \code{'show', 'interval',
#'  'rotate', 'formatter', 'textStyle'}.
#' @param checkpointStyle A list. Checkpoint style of the timeline. Default value: \cr
#' \code{list(symbol="auto", symbolSize="auto", color="auto", \cr
#' borderColor="auto", borderWidth="auto", \cr
#' label=list(show=FALSE, textStyle=list(color="auto")))}. \cr
#' Supports features of \code{'symbol', 'symbolSize', 'color', 'borderColor',
#' 'borderWidth', 'label'}.
#' @param controlStyle A list. Control style of the timeline. Default value: \cr
#' \code{list(itemSize=15, itemGap=5, normal=list(color="#333"),
#' emphasis=list(color="#1e90ff"))}. \cr
#' Supports features of \code{'itemSize', 'itemGap', 'normal', 'emphasis'}.
#' @param symbol Character. The symbol used in timeline. Default 'emptyDiamond'.
#' You can use symbols in \code{\link{setSymbolList}}.
#' @param symbolSize The size of the symbols. Default 4.
#' @param currentIndex The current index position, in correspondance with \code{z}.
#' It is used to show specific timeline slices. Default 0.
#' @param data The data list of the timeline, also used as timeline data label.
#' Default NULL.
#' @param ... Elipsis

#'
#' @return A modified echarts object
#' @export
#'
#' @references \url{http://echarts.baidu.com/echarts2/doc/option.html#title~timeline}
#' @examples
#' \dontrun{
#' ## type = "number"
#' iris$tag <- 1 + as.integer(row.names(iris)) %% 3
#' iris <- iris[order(iris$tag),]
#' g <- echartR(iris, Sepal.Width, Petal.Width, series=Species, z=tag)
#' g %>% setTimeline(y2=30, symbol='emptyCircle',
#'                   autoPlay=FALSE, data=c('tag 1', 'tag 2', 'tag 3'))
#'
#' ## type = "time"
#' ### You have to use a js function to reformat the label if you want to change
#' ### the label text
#' iris$date <- as.Date(paste0("2013-1-", 1 + as.integer(row.names(iris)) %% 5))
#' iris <- iris[order(iris$date),]
#' g <- echartR(iris, Sepal.Width, Petal.Width, series=Species, z=date)
#' g %>% setTimeline(y2=30, symbol='emptyCircle', autoPlay=FALSE, label=list(
#'       formatter=JS(paste('function(s) {return s.slice(8,10) + "\u65e5";}'))))
#' }
#'
setTimeline <- function(chart, show=TRUE, type=c('time', 'number'), realtime=TRUE,
                        x=80, y=NULL, x2=80, y2=0, width=NULL, height=50,
                        bgColor='rgba(0,0,0,0)', borderColor='#ccc',
                        borderWidth=0, controlPosition=c('left', 'right', 'none'),
                        autoPlay=FALSE, loop=TRUE, playInterval=2000,
                        lineStyle=NULL, label=NULL, checkpointStyle=NULL,
                        controlStyle=NULL, symbol='emptyDiamond', symbolSize=4,
                        currentIndex=0, data=NULL,
                        ...){
    stopifnot(inherits(chart, 'echarts'))
    if (! 'timeline' %in% names(chart$x)) return(chart)
    lst <- chart$x$timeline
    type <- match.arg(type)
    if (inherits(getMeta(chart$x$options[[1]])$z[,1], c("Date", "POSIXct", "POSIXlt"))){
        type <- 'time'
    }else{
        type <- 'number'
    }

    controlPosition <- match.arg(controlPosition)
    if (! tolower(symbol) %in% tolower(validSymbols)){
        symbol <- 'emptyDiamond'
    }else{
        symbol <- validSymbols[which(tolower(validSymbols) %in% tolower(symbol))]
    }

    ## default params
    if (! ifnull(show, TRUE)) lst$show <- show
    if (! ifnull(type, 'time') == 'time') lst$type <- type
    if (! ifnull(realtime, TRUE)) lst$realtime <- realtime
    if (! ifnull(x, 80) == 80) lst$x <- x
    if (! is.null(y)) lst$y <- y
    if (! ifnull(x2, 80) == 80) lst$x2 <- x2
    if (! ifnull(y2, 0) == 0) lst$y2 <- y2
    if (! is.null(width)) lst$width <- width
    if (! ifnull(height, 50) == 50) lst$height <- height
    if (! ifnull(bgColor, 'rgba(0,0,0,0)') == 'rgba(0,0,0,0)')
        lst$backgroundColor <- getColors(bgColor)
    if (! ifnull(borderColor, '#ccc') == '#ccc') lst$borderColor <- borderColor
    if (! ifnull(borderWidth, 0) == 0) lst$borderWidth <- borderWidth
    if (! ifnull(controlPosition, 'left') == 'left')
        lst$controlPosition <- controlPosition
    if (ifnull(autoPlay, FALSE)) lst$autoPlay <- autoPlay
    if (! ifnull(loop, TRUE)) lst$loop <- loop
    if (! ifnull(playInterval, 2000) == 2000) lst$playInterval <- playInterval

    if (! identical(ifnull(lineStyle, list(color="#666", width=1, type="dashed")),
                    list(color="#666", width=1, type="dashed"))){
        validLineStyleFeature <- c('color', 'width', 'type', 'shadowColor',
                                   'shadowBlur', 'shadowOffsetX', 'shadowOffsetY')
        if (! all(names(lineStyle) %in% validLineStyleFeature))
            stop(paste("Only supports lineStyle features as below:\n",
                       validLineStyleFeature))
        lst$lineStyle <- lineStyle
    }

    defaultLabel <- list(show=TRUE, interval="auto", rotate=0,
                         formatter=NULL, textStyle=list(color="#333"))
    if (! identical(ifnull(label, defaultLabel), defaultLabel)){
        validLabelFeature <- c('show', 'interval', 'rotate', 'formatter',
                               'textStyle')
        if (! all(names(label) %in% validLabelFeature))
            stop(paste("Only supports label features as below:\n",
                       validLabelFeature))
        lst$label <- label
    }

    defaultCheckpoint <- list(symbol="auto", symbolSize="auto", color="auto",
                              borderColor="auto", borderWidth="auto",
                              label=list(show=FALSE, textStyle=list(color="auto")))
    if (! identical(ifnull(checkpointStyle, defaultCheckpoint),
                    defaultCheckpoint)){
        validCheckpointFeature <- c('symbol', 'symbolSize', 'color', 'borderColor',
                                    'borderWidth', 'label')
        if (! all(names(checkpointStyle) %in% validCheckpointFeature))
            stop(paste("Only supports checkpointStyle features as below:\n",
                       validCheckpointFeature))
        lst$checkpointStyle <- checkpointStyle
    }

    defaultControl <- list(itemSize=15, itemGap=5, normal=list(color="#333"),
                           emphasis=list(color="#1e90ff"))
    if (! identical(ifnull(controlStyle, defaultControl), defaultControl)){
        validControlFeature <- c('itemSize', 'itemGap', 'normal', 'emphasis')
        if (! all(names(controlStyle) %in% validControlFeature))
            stop(paste("Only supports controlStyle features as below:\n",
                       validControlFeature))
        lst$controlStyle <- controlStyle
    }

    if (! ifnull(symbol, "emptyDiamond") == "emptyDiamond")
        lst$symbol <- symbol
    if (! ifnull(symbolSize, 4) == 4) lst$symbolSize <- symbolSize
    if (! ifnull(currentIndex, 0) == 0) lst$currentIndex <- currentIndex
    if (! is.null(data)) lst$data <- data
    chart$x$timeline <- lst

    return(chart %>% tuneGrid())
}

#' Add \code{markLine} to An Echarts Object
#'
#' @param chart \code{echarts} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' Short form: \cr
#' \tabular{llll}{
#'  [col 1] series name|index \tab [col 2] line name \tab [col 3] Line type
#'  \tab [col 4] Light effect \cr
#'  String or number \tab String|NA \tab min|max|average|lm \tab TRUE|FALSE
#' }
#' Full form: \cr
#' \tabular{llllllll}{
#'  [col 1] series name|index \tab [col 2] line name \tab [col 3] Value
#'  \tab [col 4] P0 x \tab [col 5] P0 y \tab [col 6] P1 x \tab [col 7] P1 y
#'  \tab [col 8] Light effect \cr
#'  String|number \tab String|NA \tab num \tab x val \tab y val \tab x val
#'  \tab y val \tab TRUE|FALSE
#' }
#' Examples:
#' \itemize{
#'  \item E.g., both \code{t(c('male', NA, 'average', FALSE))} and \code{t(c(1, NA, 'average', FALSE))}
#'  refer to an average markline of the series 'male', only available for line,
#'  linesmooth, bar, scatter, bubble charts. 'lm' refers to linear regresson
#'  markline which is only available for scatters and bubbles.
#'  \code{t(c(1, NA, 'average', TRUE))} opens light effects of series 'male'. \cr
#'  \item In line, bar, k and scatter charts, 'P0 x','P0 y','P1 x','P1 y' are
#'  comprehended as coordinates. In map charts, these coordinates should be lattitudes
#'  and longitudes. \code{t(c('male', NA, 100, 0, 5, 100, 5, TRUE))} opens light effects of series 'male'.
#' }
addMarkLine <- function(chart, ...){
    #-------markLine-----------------
    if (!is.null(MarkLine)){
        if (!is.null(z)) if (ncol(MarkLine) %in% c(5,9))
            markLine <- matrix(MarkLine[which(as.character(MarkLine[,ncol(MarkLine)])
                                              == as.character(timeslice[t])),
                                        1:(ncol(MarkLine)-1)],ncol=ncol(MarkLine)-1)
        if (! is.data.frame(markLine) & ! is.matrix(markLine)){
            stop("markLine should be a data.frame or a matrix.")
            if (!ncol(markLine) %in% c(4,8)) {
                stop("markLine should be of 4 or 8 columns")
            }
        }
        markLine <- as.data.frame(markLine,stringsAsFactors=FALSE)
        if (nrow(markLine)>0){
            if (ncol(markLine)==8){
                markLine[,6] <- gsub("^[Mm][Aa][Xx].*$",
                                     ifelse(is.numeric(x),max(Data[,xvar]*2,na.rm=TRUE),
                                            length(unique(Data[,xvar]))+1),
                                     markLine[,6])
                for (col in 3:7) markLine[,col]<-as.numeric(markLine[,col])
            }
            sermarkLine <- data.frame(name=unique(markLine[,1]),
                                      ser=NA)
            names(sermarkLine) <- c(names(markLine)[1],'ser')
            for (i in 1:nrow(sermarkLine)){
                # locate the index of lstseries to update markline
                if (!is.na(as.numeric(as.character(sermarkLine[i,1])))){ # series is index
                    if (as.numeric(as.character(sermarkLine[i,1])) <=
                        ifelse(is.null(series),1,length(lvlseries))){
                        sermarkLine[i,2] <-
                            ifelse(is.null(series),1,as.numeric(as.character(sermarkLine[i,1])))
                    }
                }else{ #series is char
                    if (!is.null(lvlseries)){
                        if (sermarkLine[i,1] %in% lvlseries){
                            sermarkLine[i,2] <- which(lvlseries==sermarkLine[i,1])
                        }
                    }
                    for (hor in 1:length(lstSeries)){
                        if (sermarkLine[i,1]==ifelse(is.null(lstSeries[[hor]][['name']]),
                                                     "",lstSeries[[hor]][['name']])){
                            sermarkLine[i,2] <- hor
                        }
                    }
                }
                if (is.na(sermarkLine[i,2])){ # new markLine series
                    sermarkLine[i,2] <- length(lstSeries)+1
                    lstSeries[[sermarkLine[i,2]]] <- list(
                        name=as.character(sermarkLine[i,1]),
                        type="line",symbol='none',
                        itemStyle=list(normal=list(lineStyle=list(type='none'))),
                        data=vector(mode='numeric')
                    )
                    if (ncol(markLine)==8){
                        if (lstXAxis[['type']] == 'category'){
                            lstSeries[[sermarkLine[i,2]]][['data']]<-
                                rep(markLine[markLine[,1]==
                                                 sermarkLine[i,1],3],
                                    ifelse(length(lstXAxis[['data']])==1,2,
                                           length(lstXAxis[['data']])))
                        }else{
                            lstSeries[[sermarkLine[i,2]]][['data']]<-
                                as.matrix(markLine[markLine[,1]==
                                                       sermarkLine[i,1],c(5,7)],
                                          dimnames=FALSE)
                        }
                    }
                    #lstLegend[['data']][[sermarkLine[i,2]]] <- markLine[i,1]
                    if (type[1]=='map'){
                        lstSeries[[sermarkLine[i,2]]][['hoverable']] <- FALSE
                        lstSeries[[sermarkLine[i,2]]][['type']] <- type[1]
                        lstSeries[[sermarkLine[i,2]]][['mapType']] <- type[2]
                    }
                }
            }
            markLine <- plyr::join(markLine,sermarkLine,by=names(markLine)[1])
            for (i in 1:nrow(sermarkLine)){
                if (type[1]=='map'){
                    lstSeries[[sermarkLine[i,2]]][['markLine']] <- list(
                        data=list(),
                        itemStyle=list(normal=list(borderWidth=1,
                                                   lineStyle=list(type='solid',shadowBlur=10))
                        )
                    )
                }
                if (!is.null(markLinesmooth)){
                    lstSeries[[sermarkLine[i,2]]][['markLine']][['smooth']] <- TRUE
                }
            }
            for (i in 1:nrow(markLine)){  # loop over markLine
                if (ncol(markLine) %in% c(9)){ # full form
                    serIdx <- markLine[i,9]
                    if (serIdx==1 || serIdx<=length(lstSeries)){
                        nLines <- length(lstSeries[[serIdx]][['markLine']][['data']])
                        lstSeries[[serIdx]][['markLine']][['data']][[nLines+1]] <-
                            list(list(name=ifelse(is.na(markLine[i,2]),
                                                  paste("P(",round(markLine[i,4],2),",",
                                                        round(markLine[i,5],2),")"),
                                                  markLine[i,2]),
                                      value=ifelse(is.na(markLine[i,3]),"-",markLine[i,3]),
                                      x=markLine[i,4],
                                      y=markLine[i,5]),
                                 list(name=ifelse(is.na(markLine[i,2]),
                                                  paste("P(",round(markLine[i,6],2),",",
                                                        round(markLine[i,7],2),")"),
                                                  ""),
                                      x=markLine[i,6],
                                      y=markLine[i,7]))
                        if (type[1] %in% c('line','linesmooth','bar','k','scatter','bubble')){
                            lstSeries[[serIdx]][['markLine']][['data']][[nLines+1]] <-
                                list(list(name=ifelse(is.na(markLine[i,2]),
                                                      paste("P(",round(markLine[i,4],2),",",
                                                            round(markLine[i,5],2),")"),
                                                      markLine[i,2]),
                                          value=markLine[i,3],
                                          xAxis=markLine[i,4],
                                          yAxis=markLine[i,5]),
                                     list(name=ifelse(is.na(markLine[i,2]),
                                                      paste("P(",round(markLine[i,6],2),",",
                                                            round(markLine[i,7],2),")"),
                                                      ""),
                                          xAxis=markLine[i,6],
                                          yAxis=markLine[i,7]))
                        }else if (type[1]=='map'){
                            geoFrom <- unlist(strsplit(as.character(markLine[i,2]),"[/|]",perl=TRUE))[1]
                            geoTo <- unlist(strsplit(as.character(markLine[i,2]),"[/|]",perl=TRUE))[2]
                            lstSeries[[serIdx]][['markLine']][['data']][[nLines+1]] <- list(
                                list(name=geoFrom),
                                list(name=geoTo)
                            )
                            if (!is.na(markLine[i,3])){
                                lstSeries[[serIdx]][['markLine']][['data']][[nLines+1]][[2]][['value']]<-
                                    markLine[i,3]
                            }
                            lstSeries[[serIdx]][['geoCoord']][[geoFrom]] <-
                                c(markLine[i,5],markLine[i,4])
                            lstSeries[[serIdx]][['geoCoord']][[geoTo]]<-
                                c(markLine[i,7],markLine[i,6])
                        }else{

                        }
                    }
                    if (markLine[i,8]==TRUE) { # effect
                        lstSeries[[serIdx]][['markLine']][['effect']] <-
                            list(show=TRUE, period=30, shadowBlur=10)
                    }
                }else if (ncol(markLine) %in% c(5)){  # short form
                    serIdx <- markLine[i,5]
                    if (type[1] %in% c('line','linesmooth','bar','scatter','bubble')){
                        if (tolower(markLine[i,3]) %in% c('min','max','average')){
                            if (serIdx==1 | serIdx<=length(lvlseries)){
                                nLines <- length(lstSeries[[serIdx]][['markLine']][['data']])
                                lstSeries[[serIdx]][['markLine']][['data']][[nLines+1]] <-
                                    list(name=ifelse(is.na(markLine[i,2]),
                                                     tolower(as.character(markLine[i,3])),
                                                     as.character(markLine[i,2])),
                                         type=tolower(as.character(markLine[i,3])))
                            }
                        }else if (type[1] %in% c('bubble','scatter') &
                                  tolower(markLine[i,3]) == 'lm'){
                            nLines <- length(lstSeries[[serIdx]][['markLine']][['data']])

                            if (is.null(series)){
                                lmfit <- lm(as.formula(paste(yvar,'~',xvar)),data)
                            }else{
                                dset <- subset(data,data[,svar]==lvlseries[serIdx])
                                lmfit <- lm(as.formula(paste(yvar,'~',xvar)),dset)
                            }
                            x1 <- min(data[,xvar])
                            x2 <- max(data[,xvar])
                            xhat <- data.frame(x=c(x1,x2))
                            names(xhat) <- xvar
                            yhat <- predict(lmfit,newdata=xhat)
                            k <- lmfit$coefficients[[2]]
                            lstSeries[[serIdx]][['markLine']][['data']][[nLines+1]] <-
                                list(list(name=ifelse(is.na(markLine[i,2]),
                                                      paste("P(",round(x1,2),",",
                                                            round(yhat[[1]],2),")"),
                                                      markLine[i,2]),
                                          value=ifelse(is.na(k),"-",round(k,2)),
                                          xAxis=x1,
                                          yAxis=yhat[[1]]),
                                     list(name=ifelse(is.na(markLine[i,2]),
                                                      paste("P(",round(x2,2),",",
                                                            round(yhat[[2]],2),"), slope"),
                                                      ""),
                                          xAxis=x2,
                                          yAxis=yhat[[2]]))
                        }
                        if (markLine[i,4]==TRUE) { # effect
                            lstSeries[[serIdx]][['markLine']][['effect']] <-
                                list(show=TRUE, period=30)
                        }
                    }
                }
            }
        }
    }
}

#' Add \code{markPoint} to An Echarts Object
#' @param chart \code{echarts} object generated by \code{\link{echart}} or \code{\link{echartR}}
#' Show markpoints, default to NULL.
#' The grammar is a data.frame or matrix with 4 or 6 columns:
#' Short form: \cr
#' \tabular{llll}{
#'  <col 1> series name|index \tab <col 2> Point name \tab <col 3> Point type \tab <col 4> Light effect \cr
#'  String or number \tab String|NA \tab min|max \tab TRUE|FALSE
#'  }
#' Full form: \cr
#' \tabular{llllll}{
#'  [col 1] series name|index \tab [col 2] Point name \tab [col 3] Value \tab [col 4] P x
#'  \tab [col 5] P y \tab [col 6] Light effect \cr
#'  String or number \tab String|NA \tab num \tab x val \tab y val \tab TRUE|FALSE
#' }
#' Examples: \cr
#' \itemize{
#'  \item E.g., both \code{t(c('male',NA,'min',FALSE))} and \code{t(c(1,NA,'min',FALSE))} refer
#'  to a min markpoint of the series 'male', only available for line, linesmooth, bar,
#'  scatter, bubble charts. \code{t(c('male',NA,'min',TRUE))} opens light effects of series 'male'.
#'  \item In line, bar, k and scatter charts, 'P x','P y',... are comprehended
#'  as coordinates. In map charts, these coordinates should be lattitudes and longitudes.
#'  \code{t(c('male',NA,100,0,5,TRUE))} opens light effects of series 'male'.
#' }
addMarkPoint <- function(chart, ...){
    #-------markPoint-----------------
    if (!is.null(markPoint)){
        if (!is.null(z)) if (ncol(markPoint) %in% c(5,7))
            markPoint <- as.matrix(MarkPoint[which(as.character(MarkPoint[,ncol(MarkPoint)])
                                                   == as.character(timeslice[t])),
                                             1:(ncol(MarkPoint)-1)],ncol=ncol(MarkPoint)-1)

        if (! is.data.frame(markPoint) & ! is.matrix(markPoint)){
            stop("markPoint should be a data.frame or a matrix.")
            if (!ncol(markPoint) %in% c(4,6)) {
                stop("markPoint should be of 4 or 6 columns")
            }else if(ncol(markPoint)==6){
                for (col in 3:5) markPoint[,col]<-as.numeric(markPoint[,col])
            }
        }
        markPoint <- as.data.frame(markPoint,stringsAsFactors=FALSE)
        sermarkPoint <- data.frame(name=levels(as.factor(markPoint[,1])),
                                   ser=NA)
        names(sermarkPoint) <- c(names(markPoint)[1],'ser')
        for (i in 1:nrow(sermarkPoint)){
            # locate the index of lstseries to update markPoint
            if (!is.na(as.numeric(as.character(sermarkPoint[i,1])))){  # series index
                if (as.numeric(as.character(sermarkPoint[i,1])) <=
                    ifelse(is.null(series),1,length(lvlseries))){
                    sermarkPoint[i,2] <-
                        ifelse(is.null(series),1,as.numeric(as.character(sermarkPoint[i,1])))
                }
            }else{
                if (!is.null(lvlseries)){
                    if (sermarkPoint[i,1] %in% lvlseries){
                        sermarkPoint[i,2] <- which(lvlseries==sermarkPoint[i,1])
                    }
                }
                for (hor in 1:length(lstSeries)){
                    if (sermarkPoint[i,1]==ifelse(is.null(lstSeries[[hor]][['name']]),
                                                  "",lstSeries[[hor]][['name']])){
                        sermarkPoint[i,2] <- hor
                    }
                }
            }
            if (is.na(sermarkPoint[i,2])){ #new markPoint series
                sermarkPoint[i,2] <- length(lstSeries)+1
                lstSeries[[sermarkPoint[i,2]]] <- list(
                    name=as.character(sermarkPoint[i,1]),
                    type="scatter",
                    data=vector(mode="numeric")
                )
                #lstLegend[['data']][[sermarkPoint[i,2]]] <- markPoint[i,1]
            }
            if (type[1]=='map'){
                lstSeries[[sermarkPoint[i,2]]][['type']] <- "map"
                lstSeries[[sermarkPoint[i,2]]][['mapType']] <- type[2]
                lstSeries[[sermarkPoint[i,2]]][['markPoint']] <- list(
                    symbol='emptyCircle',
                    itemStyle=list(normal=list(label=list(show=FALSE))),
                    data=list()
                )
            }
        }
        markPoint <- plyr::join(markPoint,sermarkPoint,by=names(markPoint)[1])

        for (i in 1:nrow(markPoint)){  # loop over markPoint
            if (ncol(markPoint) %in% c(7)){ # full form
                serIdx <- markPoint[i,7]
                if (serIdx==1 | serIdx<=length(lstSeries)){
                    nPoints <- length(lstSeries[[serIdx]][['markPoint']][['data']])
                    if (!is.na(markPoint[i,3])){
                        lstSeries[[serIdx]][['markPoint']][['data']][[nPoints+1]] <-
                            list(name=ifelse(is.na(markPoint[i,2]),
                                             paste("P(",round(markPoint[i,4],2),",",
                                                   round(markPoint[i,5],2),")"),
                                             markPoint[i,2]),
                                 value=ifelse(is.numeric(markPoint[i,3]),
                                              round(as.numeric(markPoint[i,3]),2),
                                              markPoint[i,3]),
                                 x=markPoint[i,4],
                                 y=markPoint[i,5])
                    }
                    if (type[1] %in% c('line','linesmooth','bar','k','scatter')){
                        lstSeries[[serIdx]][['markPoint']][['data']][[nPoints+1]] <-
                            list(name=ifelse(is.na(markPoint[i,2]),
                                             paste("P(",round(markPoint[i,4],2),",",
                                                   round(markPoint[i,5],2),")"),
                                             markPoint[i,2]),
                                 value=ifelse(is.na(markPoint[i,3]),"-",
                                              round(as.numeric(markPoint[i,3]),2)),
                                 xAxis=markPoint[i,4],
                                 yAxis=markPoint[i,5])
                    }else if (type[1] =='map'){
                        if (!is.na(markPoint[i,3])){
                            lstSeries[[serIdx]][['markPoint']][['data']][[nPoints+1]] <-
                                list(name=markPoint[i,2],
                                     value=ifelse(is.numeric(markPoint[i,3]),
                                                  round(as.numeric(markPoint[i,3]),2),
                                                  markPoint[i,3]))
                        }
                        if (!any(is.na(markPoint[i,4:5]))){
                            lstSeries[[1]][['geoCoord']][[markPoint[i,2]]] <-
                                c(markPoint[i,5],markPoint[i,4])
                        }  # all geoCoords append to series 1
                    }
                }

                if (markPoint[i,6]==TRUE) { # effect
                    lstSeries[[serIdx]][['markPoint']][['effect']] <-
                        list(show=TRUE, shadowBlur=0)
                }

            }else if (ncol(markPoint) %in% c(5)){  # short form
                serIdx <- markPoint[i,5]
                if (type[1] %in% c('line','linesmooth','bar','scatter','bubble')){
                    if (tolower(markPoint[i,2]) %in% c('min','max')){
                        if (serIdx==1 | serIdx<=length(lvlseries)){
                            nPoints <- length(lstSeries[[serIdx]][['markPoint']][['data']])
                            lstSeries[[serIdx]][['markPoint']][['data']][[nPoints+1]] <-
                                list(name=ifelse(is.na(markPoint[i,2]),
                                                 tolower(markPoint[i,3]),
                                                 markPoint[i,2]),
                                     type=tolower(markPoint[i,3]))
                        }
                    }
                    if (markPoint[i,4]==TRUE) { # effect
                        lstSeries[[serIdx]][['markPoint']][['effect']] <- list(show=TRUE)
                    }
                }
            }
            if (length(markPoint)>1000) {
                lstSeries[[serIdx]][['markPoint']][['large']] <- T
            }
        }
        if (ncol(markPoint)==7) { #JS func symbolSize, max 20, min 10
            sizeFold <- 10/(1+diff(range(markPoint[,3])))
            for (i in 1:nrow(sermarkPoint)){
                lstSeries[[sermarkPoint[i,2]]][['markPoint']][['symbolSize']] <-
                    JS('function (value) {
                       return 10+(value-',min(markPoint[,3]),')*',
                       sizeFold,'}')
            }
    }
    }
}

#---------------------Legacy eAxis functions----------------------------
eAxis = function(
    # Create an axis for a chart
    #
    # Add an axis to a chart.
    #
    # This function modified a few default options for the axis component in
    # ECharts: 1) \code{scale = TRUE} (was \code{FALSE} by default in ECharts); 2)
    # \code{axisLine$onZero = FALSE} (was \code{TRUE} in ECharts).
    # @rdname axis
    chart, which = c('x', 'y'),
    type = c('value', 'category', 'time', 'log'), show = TRUE,
    position = c('bottom', 'top', 'left', 'right'),
    name = '', nameLocation = c('end', 'start'), nameTextStyle = emptyList(),
    boundaryGap = c(0, 0), min = NULL, max = NULL, scale = TRUE, splitNumber = NULL,
    axisLine = list(show = TRUE, onZero = FALSE), axisTick = list(show = FALSE),
    axisLabel = list(show = TRUE), splitLine = list(show = TRUE),
    splitArea = list(show = FALSE), data = list()
) {
    which = match.arg(which)
    odata = getMeta(chart)[[which]]  # original data along the axis
    if (missing(type)) type = axisType(odata, which)
    if (missing(position)) position = if (which == 'x') 'bottom' else 'left'
    if (missing(data) && type == 'category') {
        data = I(levels(as.factor(odata)))
    }

    x = chart$x
    i = paste0(which, 'Axis')
    o = list(
        type = match.arg(type), show = show, position = match.arg(position),
        name = name, nameLocation = match.arg(nameLocation), nameTextStyle = nameTextStyle,
        boundaryGap = boundaryGap, min = min, max = max, scale = scale,
        splitNumber = splitNumber, axisLine = axisLine, axisTick = axisTick,
        axisLabel = axisLabel, splitLine = splitLine, splitArea = splitArea, data = data
    )
    if (length(x[[i]])) {
        # only merge the arguments that are not missing, e.g. eAxis(min = 0) will
        # only override 'min' but will not override the 'name' attribute
        a = intersect(names(as.list(match.call()[-1])), names(o))  #;browser()
        x[[i]] = mergeList(x[[i]], o[a])
    } else {
        x[[i]] = mergeList(x[[i]], o)
    }
    chart$x = x

    return(chart)
}


eXAxis = function(chart, ...) {
    # @rdname axis
    eAxis(chart, which = 'x', ...)
}


eYAxis = function(chart, ...) {
    # @rdname axis
    eAxis(chart, which = 'y', ...)
}
